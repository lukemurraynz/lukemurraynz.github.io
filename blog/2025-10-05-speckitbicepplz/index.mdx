---
title:
metaDescription: 
tags:
  - Azure
categories:
  - Azure
authors:
  - Luke
slug: azure/
keywords:
  - Azure
description:
date:
---

Today we are going to look at  Spec Kit, and using Spec-Driven Development to create a [Platform Landing Zone](https://learn.microsoft.com/azure/cloud-adoption-framework/ready/?WT.mc_id=AZ-MVP-5004796#platform-landing-zone) aligned to the [Well-Architected Framework](https://learn.microsoft.com/azure/well-architected/?WT.mc_id=AZ-MVP-5004796), using [Bicep](https://learn.microsoft.com/azure/azure-resource-manager/bicep/overview?tabs=bicep&WT.mc_id=AZ-MVP-5004796) as the Infrastructure as Code.

{/* truncate */}

:::info
[GitHub Spec Kit](https://github.com/github/spec-kit) brings a new approach to AI-based software development workflows – instead of vibe coding every new feature and bug fix teams can preemptively outline the concrete project requirements, motivations, and technical aspects before handing that off to AI agents and have them build exactly what was needed in the first place. If you’ve ever worked with product managers that had to put together Product Requirements Documents (PRDs) that need to be reviewed and then implemented, you might hear some echoes of a familiar process.

Spec-Driven Development, or SDD, is not about writing exhaustive, dry requirements documents that nobody reads. It’s also not about waterfall planning or trying to predict the future through extensive planning exercises. And it’s definitely not about creating more bureaucracy that slows engineering teams down.

SDD is about making your technical decisions explicit, reviewable, and evolvable. Think of it as version control for your thinking. Instead of having crucial architectural decisions trapped in email threads, scattered documents, or locked in someone’s head, you capture the "why" behind your technical choices in a format that can grow with your project and your understanding of the problem space.

Spec-Driven Development (SDD) is a software development approach where detailed, structured specifications are created first and act as the single source of truth to guide the entire development process—from planning and design to implementation and testing. This method replaces ambiguity and disparate requirements with clear, executable specifications, which can now be used by AI agents to automatically generate working code, tests, and documentation, leading to greater precision and efficiency. 

You can read more about Spec Kit and Spec-Driven Development [here](https://github.com/github/spec-kit/blob/main/spec-driven.md).
:::

So lets get started.

First we need to install Spec Kit. I will be running this from a devcontainer, but you can install the [Specify CLI](https://github.com/github/spec-kit#1-install-specify) directly on your machine if you prefer, or just copy the files from the latest set of Releases [github/spec-kit](https://github.com/github/spec-kit/releases). The CLI is not needed, but it does help you bootstrap, the latest prompts and check that all the necessary dependencies _(ie your using the right IDE, git initialization)_ are in place.

Spec Kit is a collection of prompts and workflows that guide you through the Spec-Driven Development process. It uses AI to help you create and manage specifications, plans, and tasks for your software projects.

| Command | Description | Why It's Needed |
|---------|-------------|-----------------|
| `/constitution` | Create or update project governing principles and development guidelines | Establishes immutable architectural principles (9 articles) that ensure consistency, simplicity, and quality across all generated code. Acts as the "DNA" of your project, preventing over-engineering and maintaining architectural integrity. |
| `/specify` | Define what you want to build (requirements and user stories) | Transforms vague feature ideas into comprehensive, structured specifications with automatic repository management. Creates feature branches, proper directory structure, and complete PRDs with user stories and acceptance criteria - focusing on WHAT and WHY, not HOW. |
| `/clarify` | Clarify underspecified areas (must be run before /plan unless explicitly skipped) | Identifies and resolves ambiguities marked with `[NEEDS CLARIFICATION]` tags in specifications. Prevents AI from making incorrect assumptions and ensures all requirements are explicitly defined before technical planning begins. |
| `/plan` | Create technical implementation plans with your chosen tech stack | Converts business requirements into detailed technical architecture and implementation details. Generates supporting documents (data models, API contracts, test scenarios) while ensuring constitutional compliance and architectural principles are followed. |
| `/tasks` | Generate actionable task lists for implementation | Analyzes the implementation plan and converts it into specific, executable tasks. Identifies parallelizable work streams and creates a structured roadmap that maps directly from specifications to concrete development actions. |
| `/analyze` | Cross-artifact consistency & coverage analysis (run after /tasks, before /implement) | Validates consistency across all specification artifacts, identifies gaps or contradictions, and ensures complete coverage of requirements before implementation begins. Acts as a quality gate to prevent specification drift. |
| `/implement` | Execute all tasks to build the feature according to the plan | Generates working code from the specifications and implementation plans. Follows test-first development (Article III), creates modular libraries (Article I), and ensures all code aligns with the established constitutional principles. |

We are going to go through the process of creating a new project, defining the constitution, specifying what we want to build, planning the technical implementation, generating tasks, analyzing for consistency, and finally implementing the code for a Platform Landing Zone.

I love that specification development is front and centre, and that the process encourages you to think about the "why" and "what" before jumping into the "how". This is a great way to ensure that the end result is actually what was needed, and not just what was easy to implement, so lets get started.

First we will initialize our project and creating our constitution. The model I will be using throughput the post will be GPT-5, for the spec driven development, and then when it comes to implement we will see how we go with GPT-5-Codex.

```bash
mkdir speckitbicepplz
cd speckitbicepplz
specify init
```

