"use strict";(self.webpackChunklukemurraynz=self.webpackChunklukemurraynz||[]).push([[6674],{75e3:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>u,default:()=>p,frontMatter:()=>c,metadata:()=>o,toc:()=>d});var o=t(80204),i=t(74848),r=t(28453),s=t(11470),a=t(19365);const c={title:"Automate Azure Bastion with Drasi Realtime RBAC Monitoring",metaDescription:"Use Drasi to monitor Azure Role Assignments and automate Azure Bastion creation or deletion in real-time.",tags:["Azure"],categories:["Azure"],authors:["Luke"],slug:"azure/drasi-bastion-rbac-automation",keywords:["Azure","Drasi","Azure Bastion","RBAC","Role-Based Access Control","Event-driven architecture","Real-time monitoring","Azure Activity Logs","Event Hub","Azure Functions","PowerShell","AKS","Kubernetes","Event Grid","Automation","Infrastructure as Code","Change Data Processing","Cypher query language","VM Administrator Login","Workload Identity","Managed Identity","Azure Resource Manager","Cloud Native Computing Foundation","CNCF"],description:"Learn to automate Azure Bastion creation and deletion in real-time using Drasi to monitor Azure Role Assignments.",date:new Date("2025-06-21T13:25:24.603Z")},u=void 0,l={authorsImageUrls:[void 0]},d=[{value:"\ud83d\ude80 Introduction to Drasi",id:"-introduction-to-drasi",level:2},{value:"\ud83d\udccb Understanding Drasi Components",id:"-understanding-drasi-components",level:2},{value:"\ud83c\udfaf Our Azure Bastion Automation Scenario",id:"-our-azure-bastion-automation-scenario",level:2},{value:"\ud83d\udee0\ufe0f Setting Up Drasi Environment",id:"\ufe0f-setting-up-drasi-environment",level:2},{value:"\ud83c\udfd7\ufe0f Azure Resources Required",id:"\ufe0f-azure-resources-required",level:2},{value:"Important Notes",id:"important-notes",level:3},{value:"\ud83d\ude80 Installing Drasi on AKS",id:"-installing-drasi-on-aks",level:2},{value:"\ud83d\udcca Configuring Azure Activity Logs",id:"-configuring-azure-activity-logs",level:2},{value:"\ud83d\udd10 Setting Up Authentication with Workload Identity",id:"-setting-up-authentication-with-workload-identity",level:2},{value:"\ud83d\udce1 Creating Drasi Event Hub Source",id:"-creating-drasi-event-hub-source",level:2},{value:"\ud83d\udd0d Building the Continuous Query",id:"-building-the-continuous-query",level:2},{value:"\ud83e\udde0 Understanding the Continuous Query Logic",id:"-understanding-the-continuous-query-logic",level:2},{value:"\u26a1 Creating the Event Grid Reaction",id:"-creating-the-event-grid-reaction",level:2},{value:"\ud83d\udd27 Building the Azure Function App",id:"-building-the-azure-function-app",level:2},{value:"\ud83d\udcdd Function App Architecture",id:"-function-app-architecture",level:2},{value:"\ud83d\ude80 Deploying the Function App",id:"-deploying-the-function-app",level:2},{value:"\ud83e\uddea Testing the Complete System",id:"-testing-the-complete-system",level:2}];function h(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://drasi.io/",children:"Drasi"})," ",(0,i.jsx)(n.em,{children:"(named after the Greek word for 'Action')"})," is a change data processing platform that automates real-time detection, evaluation, and meaningful reaction to events in complex, event-driven systems, created as part of the ",(0,i.jsx)(n.a,{href:"https://azure.microsoft.com/blog/drasi-microsofts-newest-open-source-project-simplifies-change-detection-and-reaction-in-complex-systems/?WT.mc_id=AZ-MVP-5004796",children:"Azure Incubation Teams, Drasi"})," was accepted in to the ",(0,i.jsx)(n.a,{href:"https://www.cncf.io/projects/drasi/",children:"Cloud Native Computing Foundation, at the Sandbox Maturity level in January of 2025"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"I was fortunate enough to witness a demo of this in action and wondered how I might learn to use Drasi with something I am familiar with - the Microsoft Azure ecosystem. The Azure Role Assignment Monitor with Drasi was born."}),"\n","\n",(0,i.jsx)(n.h2,{id:"-introduction-to-drasi",children:"\ud83d\ude80 Introduction to Drasi"}),"\n",(0,i.jsxs)(n.admonition,{type:"info",children:[(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://drasi.io/",children:"Drasi"})," is a Data Change Processing platform that makes it easier to build dynamic solutions that detect and react to data changes that occur in existing databases and software systems (i.e., not only new systems built using Drasi). Drasi\u2019s change detection capabilities extend beyond simply reporting add, update, and delete operations, as typically provided by database transaction/change logs and message-based change notification solutions. Instead, Drasi\u2019s low-code query-based approach enables you to write rich graph queries through which you can express sophisticated rules describing the types of changes you want to detect and the data you want to distribute about those changes to downstream systems."]}),(0,i.jsx)(n.p,{children:"Here are some examples of scenarios where Drasi\u2019s functionality can be applied to existing systems to detect and react to changing data:"}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Observing data from building sensors and automatically adjusting HVAC settings to maintain a comfortable environment for building occupants."}),"\n",(0,i.jsx)(n.li,{children:"Risk management through early awareness of company employees, facilities, and assets that are at risk due to emerging incidents occurring in their current location."}),"\n",(0,i.jsx)(n.li,{children:"Optimizing the delivery of orders to customers when they arrive in a curbside pickup zone."}),"\n",(0,i.jsx)(n.li,{children:"Improving infrastructure threat detection by raising alerts when a container with known security threats is deployed to a Kubernetes Cluster."}),"\n"]}),(0,i.jsx)(n.h2,{id:"-understanding-drasi-components",children:"\ud83d\udccb Understanding Drasi Components"}),(0,i.jsx)(n.p,{children:"The power of Drasi is the components:"}),(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Drasi components",src:t(23680).A+"",width:"2048",height:"669"})}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Sources"}),"\n",(0,i.jsx)(n.li,{children:"Continuous queries"}),"\n",(0,i.jsx)(n.li,{children:"Reactions"}),"\n"]}),(0,i.jsx)(n.p,{children:"You can have multiple sources, which are the data sources that Drasi monitors for changes. These can be databases, message queues, or any other system that can provide change data. A number of provided sources exist out of the box - CosmosDB, MySQL, PostgreSQL, Event Hub, SQL Server, Kubernetes, Dataverse."}),(0,i.jsxs)(n.p,{children:["These ",(0,i.jsx)(n.a,{href:"https://drasi.io/concepts/sources/",children:"sources"})," are monitored for changes, and when a change is detected, it is processed by a continuous query. Sources act like skilled translators. They watch a system\u2019s native log or feed, convert inserts/updates/deletes into a consistent graph form, and push only the meaningful deltas to the engine.\nA ",(0,i.jsx)(n.a,{href:"https://drasi.io/concepts/continuous-queries/",children:"continuous query"})," is a query that runs continuously and processes the changes detected by the source. The continuous query can be used to filter, transform, and aggregate the data from the source. Drasi leverages a subset of the Cypher graph query language because it excels at expressing patterns\u2014entities and relationships\u2014across multiple data sources. You write a one-time MATCH/WHERE/RETURN query that continually runs under the covers.\n",(0,i.jsx)(n.a,{href:"https://drasi.io/concepts/reactions/",children:"Reactions"})," are the actions that are taken when a change is detected and processed by the continuous query. Reactions can be used to send notifications, update other systems, or trigger other actions. Drasi provides a number of reactions out of the box - Azure Functions, Logic Apps, Webhooks, and more. Reactions subscribe to one or more Continuous Queries and trigger real-world actions when those queries\u2019 result sets change. Because Reactions consume the structured \u201cQuery Result Change\u201d payload\u2014detailing exactly which nodes or relationships were added, updated, or removed\u2014they can make fully informed decisions without re-polling underlying systems."]}),(0,i.jsx)(n.p,{children:"Imagine a smart-building scenario:"}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Source: Drasi watches Azure Cosmos DB for room-temperature updates and PostgreSQL for occupancy schedules."}),"\n",(0,i.jsx)(n.li,{children:"Continuous Query: A single Cypher query joins rooms, sensors, and schedules to detect \u201coccupied room < 18\xb0C\u201d conditions."}),"\n",(0,i.jsx)(n.li,{children:"Reaction: When that condition appears in the CQ\u2019s result set, a Reaction module fires a heating command via MQTT; when it no longer applies, another Reaction module stops the heater."}),"\n"]}),(0,i.jsx)(n.p,{children:"Because Sources supply clean graph events, the CQ keeps an always-correct view without heavy polling, and Reactions act on precise change notifications, the entire pipeline runs at low latency and minimal operational overhead. No custom glue code. No brittle cron jobs."})]}),"\n",(0,i.jsx)(n.h2,{id:"-our-azure-bastion-automation-scenario",children:"\ud83c\udfaf Our Azure Bastion Automation Scenario"}),"\n",(0,i.jsxs)(n.p,{children:["In my scenario, I wanted to monitor the Azure Role Assignments in my Azure Subscription, my example is the use of the ",(0,i.jsx)(n.a,{href:"https://learn.microsoft.com/azure/bastion/bastion-overview?WT.mc_id=AZ-MVP-5004796",children:"Azure Bastion"})," Service, this services allows secure RDP and SSH connectivity to virtual machines in your Azure Virtual Network without the need for a public IP address on the virtual machine. This is a great service, it does require a role assignment to be able to use it, and its a pay as you go service - so I may not necessarily need it running all the time, wasting cost. Because I might require this service very ad-hoc, I couldn't rely on a schedule-type system I'd usually use ",(0,i.jsx)(n.em,{children:"(ie, tag the resource with the schedule, have an Azure runbook create and delete the resource)"}),". There are other ways to monitor Azure Role Assignments, but I wanted to use Drasi to monitor the changes in real-time and react to them, in a way that could be expanded."]}),"\n",(0,i.jsx)(n.p,{children:"So my scenario is:"}),"\n",(0,i.jsx)(n.p,{children:"When Sarah from Marketing needs access to a VM:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:['An admin assigns her "VM Administrator Login" role ',(0,i.jsx)(n.em,{children:"(manually or via a PIM assignment)"})]}),"\n",(0,i.jsx)(n.li,{children:"Automatically, this system detects the change"}),"\n",(0,i.jsx)(n.li,{children:"Automatically, it creates a secure Bastion host"}),"\n",(0,i.jsx)(n.li,{children:"Sarah can now securely connect to the VM"}),"\n",(0,i.jsx)(n.li,{children:"When her access is revoked, the Bastion is automatically cleaned up"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["\ud83d\udccb Azure Activity Logs \u2192 \ud83d\udce8 Event Hub \u2192 \ud83d\udd0d Drasi \u2192 \ud83d\udce7 Event Grid \u2192 \u26a1 Azure Function \u2192 \ud83d\udee1\ufe0f Create/Delete Bastion ",(0,i.jsx)(n.em,{children:"(or Ignore)"})]}),"\n",(0,i.jsxs)(n.p,{children:["Azure Activity Logs: Every action in Azure ",(0,i.jsx)(n.em,{children:"(like assigning roles)"})," gets logged\nEvent Hub: Collects these logs in real-time\nDrasi Source: Reads events from the Event Hub\nDrasi Continuous Query: Filters for role assignment events we care about\nDrasi Reaction: Sends notifications to Event Grid when matches are found\nAzure Function: Receives the notification and takes action, adds additional logic as needed to filter results and take action\nBastion Management: Creates or removes Azure Bastion hosts as needed"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Drasi",src:t(78600).A+"",width:"3766",height:"1010"})}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsxs)(n.p,{children:["There is a delay between the diagnostic logs being written to the Event Hub; it can take a few minutes for the role assignment changes to be logged. This is not a Drasi issue, but an Azure Event Hub/Azure Monitor export issue, it can take up to 5 minutes for the logs to be written to the Event Hub ",(0,i.jsx)(n.em,{children:"(but once they are, Drasi picks it up within seconds)"}),". In my testing, I was able to fast-track my testing by publishing the Event Hub message directly into the Event Hub data explorer, without needing to go and manually wait for the role assignment to be created or deleted."]})}),"\n",(0,i.jsx)(n.h2,{id:"\ufe0f-setting-up-drasi-environment",children:"\ud83d\udee0\ufe0f Setting Up Drasi Environment"}),"\n",(0,i.jsxs)(n.p,{children:["So, first things first, let's get ",(0,i.jsx)(n.a,{href:"https://drasi.io/",children:"Drasi"})," up and running! To do this, I am going to use a ",(0,i.jsx)(n.a,{href:"https://github.com/features/codespaces",children:"GitHub Codespace"})," - you can find my devcontainer setup ",(0,i.jsx)(n.a,{href:"https://github.com/lukemurraynz/Drasi-RoleAssignmentMonitor/blob/main/.devcontainer/devcontainer.json",children:"here"})," - this will allow me to run Drasi in a container via docker if I want, but the main part is - it will already install the latest Drasi CLI, and have all the dependencies I need to deploy Drasi to my Azure Kubernetes Service, and manage it - such as the ",(0,i.jsx)(n.a,{href:"https://marketplace.visualstudio.com/items?itemName=DrasiProject.drasi",children:"Drasi Visual Studio Code extension"})," - all the code in this example is in this repository as well ",(0,i.jsx)(n.em,{children:"(ie Drasi query, Function App)"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"To do this, I am going to deploy to an Azure Kubernetes Service cluster. The size of the cluster will depend on your use case. For my purposes, I am going with the following resources:"}),"\n",(0,i.jsx)(n.h2,{id:"\ufe0f-azure-resources-required",children:"\ud83c\udfd7\ufe0f Azure Resources Required"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Resource Type"}),(0,i.jsx)(n.th,{children:"Name"}),(0,i.jsx)(n.th,{children:"Region"}),(0,i.jsx)(n.th,{children:"Configuration"}),(0,i.jsx)(n.th,{children:"Purpose"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"AKS Cluster"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"drasi-aks"})}),(0,i.jsx)(n.td,{children:"New Zealand North"}),(0,i.jsxs)(n.td,{children:["\u2022 Standard Cluster \u2022 System Pool: Standard_D4ds_v5 \u2022 User Pool: Standard_D4s_v5 \u2022 Workload Identity enabled \u2022 Namespace: ",(0,i.jsx)(n.code,{children:"drasi-system"})]}),(0,i.jsx)(n.td,{children:"Hosts Drasi and runs query host for Continuous Queries"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"User Assigned Managed Identity"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"drasi-mi"})}),(0,i.jsx)(n.td,{children:"New Zealand North"}),(0,i.jsxs)(n.td,{children:["\u2022 Role: ",(0,i.jsx)(n.code,{children:"Azure Event Hubs Data Receiver"})," \u2022 OIDC connection to AKS"]}),(0,i.jsx)(n.td,{children:"Authentication for Drasi to access Event Hub"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Event Hub Namespace"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"azrole"})}),(0,i.jsx)(n.td,{children:"New Zealand North"}),(0,i.jsxs)(n.td,{children:["\u2022 Standard tier \u2022 1 throughput unit \u2022 Hub name: ",(0,i.jsx)(n.code,{children:"drasieventhub1"})]}),(0,i.jsx)(n.td,{children:"Drasi source - collects Azure Activity Logs"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Event Grid Topic"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"drasi-eventgrid-topic"})}),(0,i.jsx)(n.td,{children:"New Zealand North"}),(0,i.jsx)(n.td,{children:"\u2022 Basic tier \u2022 Schema: CloudEvents v1.0 \u2022 Azure Function subscription"}),(0,i.jsx)(n.td,{children:"Drasi reaction - sends notifications when changes detected"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Azure Function App"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"drasi-function-app"})}),(0,i.jsx)(n.td,{children:"Australia East*"}),(0,i.jsx)(n.td,{children:"\u2022 Linux Flex Consumption plan \u2022 PowerShell Core runtime"}),(0,i.jsx)(n.td,{children:"Creates/deletes Azure Bastion based on role assignments"})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:["* ",(0,i.jsx)(n.em,{children:"Australia East region used as this SKU is not available in New Zealand North"})]}),"\n",(0,i.jsx)(n.h3,{id:"important-notes",children:"Important Notes"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"AKS VM Sizing"}),": If you encounter errors with the Drasi API and query host starting, check your User pool VM size. Standard_D4s_v5 works well, but smaller sizes may cause issues with Drasi and Dapr runtime."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Workload Identity"}),": The AKS cluster must have ",(0,i.jsx)(n.a,{href:"https://learn.microsoft.com/azure/aks/workload-identity-deploy-cluster?WT.mc_id=AZ-MVP-5004796",children:"Workload identity enabled"})," for proper authentication."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"I won't go through the creation of these resources individually; instead, I will focus on how they are used in relation to our Drasi Azure Role Assignment Monitor setup."}),"\n",(0,i.jsx)(n.h2,{id:"-installing-drasi-on-aks",children:"\ud83d\ude80 Installing Drasi on AKS"}),"\n",(0,i.jsxs)(n.p,{children:["So we have our Azure resources created, and we can now deploy Drasi to our AKS cluster. To do this, we will use the ",(0,i.jsx)(n.a,{href:"https://drasi.io/docs/cli/",children:"Drasi CLI"}),", which is installed in the devcontainer I mentioned earlier. Alternatively, you can install it locally if you prefer."]}),"\n",(0,i.jsx)(n.p,{children:"First, we will connect to our AKS cluster and confirm we can see the namespace before running the drasi init command to deploy Drasi to our AKS cluster:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Install kubectl if not already installed\nsudo az aks install-cli\n\n# Login to Azure and get cluster credentials\naz login\naz aks get-credentials --resource-group <your-resource-group> --name <your-cluster-name>\n\n# Check Drasi version\ndrasi version\n\n# Initialize Drasi on Kubernetes\ndrasi init --namespace drasi-system --version 0.3.4\n\n# Verify installation\nkubectl get pods -n drasi-system\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Drasi pods running",src:t(11397).A+"",width:"1248",height:"311"})}),"\n",(0,i.jsx)(n.h2,{id:"-configuring-azure-activity-logs",children:"\ud83d\udcca Configuring Azure Activity Logs"}),"\n",(0,i.jsx)(n.p,{children:"Now that we have Drasi running in our AKS cluster, we can start the additional configuration. Let us configure our Azure Activity Logs to be sent to our Event Hub, so that Drasi can monitor them for changes. To do this, we will need to create a diagnostic setting on our subscription and configure it to send the Activity Logs to our Event Hub."}),"\n",(0,i.jsxs)(n.p,{children:["Role-based assignments are an Administrative category, so we will need to select the ",(0,i.jsx)(n.code,{children:"Administrative"})," category when creating the diagnostic setting. You can do this via the Azure Portal by navigating to your subscription, selecting Activity Log, select Export Activity Logs, and then selecting the Event Hub you created earlier."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Azure Activity Log Diagnostic Setting",src:t(88194).A+"",width:"1890",height:"966"})}),"\n",(0,i.jsxs)(n.p,{children:["Once you have created the diagnostic setting, you can verify that the logs are being sent to the Event Hub by using the ",(0,i.jsx)(n.a,{href:"https://learn.microsoft.com/azure/event-hubs/event-hubs-data-explorer?WT.mc_id=AZ-MVP-5004796",children:"Azure Event Hub Data Explorer"}),". It can take a few minutes for the logs to start appearing."]}),"\n",(0,i.jsx)(n.h2,{id:"-setting-up-authentication-with-workload-identity",children:"\ud83d\udd10 Setting Up Authentication with Workload Identity"}),"\n",(0,i.jsxs)(n.p,{children:["Next, it's time to configure our Drasi source to read from the Event Hub. We are going to use Entra ID authentication to authenticate Drasi to the Event Hub, and this is where the Workload Identity we created earlier comes in. We will need to create a User Assigned Managed Identity and assign it the ",(0,i.jsx)(n.code,{children:"Azure Event Hubs Data Receiver"})," role on the Event Hub namespace."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"User Assigned Managed Identity",src:t(83004).A+"",width:"1434",height:"332"})}),"\n",(0,i.jsx)(n.p,{children:"Now we need to grab the Issuer URL and Client ID of the User Assigned Managed Identity, we will need these to configure our federated credential, and configure out federated credential. Make sure to update for your own environment, the source name needs to align with your source name, and the service account to your namespace."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'# Variables\nAKS_NAME="drasi-azroleassignment-aks"\nRG_NAME="drasi-azrolemonitor-rg"\nMI_NAME="drasi-mi"\nFC_NAME="drasi-eventhub"\nSUBJECT="system:serviceaccount:drasi-system:source.azure-role-eventhub-source"\nAUDIENCE="api://AzureADTokenExchange"\n\n# Get the OIDC issuer URL for the AKS cluster\nISSUER_URL=$(az aks show --name "$AKS_NAME" --resource-group "$RG_NAME" --query "oidcIssuerProfile.issuerUrl" -o tsv)\n\n# Create federated credential\naz identity federated-credential create \\\n    --name "$FC_NAME" \\\n    --identity-name "$MI_NAME" \\\n    --resource-group "$RG_NAME" \\\n    --issuer "$ISSUER_URL" \\\n    --subject "$SUBJECT" \\\n    --audience "$AUDIENCE"\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Create Federated Credential",src:t(67939).A+"",width:"1266",height:"320"})}),"\n",(0,i.jsx)(n.h2,{id:"-creating-drasi-event-hub-source",children:"\ud83d\udce1 Creating Drasi Event Hub Source"}),"\n",(0,i.jsx)(n.p,{children:"Now we can create our Drasi source:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",metastring:'title="eventhubsource.yaml"',children:"kind: Source\napiVersion: v1\nname: azure-role-eventhub-source\nspec:\n  kind: EventHub\n  identity:\n    kind: MicrosoftEntraWorkloadID\n    clientId: 50421fa8-277f-4c22-a085-d5880422dc52\n  properties:\n    host: azrole.servicebus.windows.net\n    eventHubs:\n      - drasieventhub1\n    bootstrapWindow: 5\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Update the ",(0,i.jsx)(n.code,{children:"clientId"})," with your User Assigned Managed Identity Client ID, and the ",(0,i.jsx)(n.code,{children:"host"})," with your Event Hub namespace. You can then apply this source to your Drasi cluster:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"drasi apply -f eventhubsource.yaml\n"})}),"\n",(0,i.jsx)(n.p,{children:"Then check the status of the source:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"drasi list source\n# Output should show the source is Available.\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Drasi Source",src:t(70515).A+"",width:"1617",height:"883"})}),"\n",(0,i.jsx)(n.h2,{id:"-building-the-continuous-query",children:"\ud83d\udd0d Building the Continuous Query"}),"\n",(0,i.jsxs)(n.p,{children:["Now that we have our source configured. It's time to create our Continuous Query. This is the query that will filter the Azure Activity Logs for the role assignment events we care about. We will use the Cypher query language to do this. It's worth noting that Drasi uses a subset of the Cypher query language (",(0,i.jsx)(n.a,{href:"https://drasi.io/reference/query-language/",children:"https://drasi.io/reference/query-language/"}),"), so not all Cypher queries will work."]}),"\n",(0,i.jsxs)(n.p,{children:["Make sure to update to the source name to match your source name, and the label to match the label ",(0,i.jsx)(n.em,{children:"(ie, the name of the Event Hub (the hub, not the namespace))"})," you want to use for the role assignment events."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",metastring:'title="azure-role-change-vmadminlogin.yaml"',children:"kind: ContinuousQuery\napiVersion: v1\nname: azure-role-change-vmadminlogin\nspec:\n  mode: query\n  sources:\n    subscriptions:\n      - id: azure-role-eventhub-source\n        nodes:\n          - sourceLabel: drasieventhub1\n        pipeline:\n          - extract-role-assignments\n    middleware:\n      - name: extract-role-assignments\n        kind: unwind\n        drasieventhub1:\n          - selector: $.records[?(@.operationName == 'MICROSOFT.AUTHORIZATION/ROLEASSIGNMENTS/WRITE' || @.operationName == 'MICROSOFT.AUTHORIZATION/ROLEASSIGNMENTS/DELETE')]\n            label: RoleAssignment\n            key: $.time\n            properties:\n              time: $.time\n              resourceId: $.resourceId\n              operationName: $.operationName\n              operationType: $.resultType\n              category: $.category\n              level: $.level\n              correlationId: $.correlationId\n              caller: $.identity.claims.name\n              callerIpAddress: $.callerIpAddress\n              tenantId: $.tenantId\n              subscriptionId: $.identity.authorization.scope\n              status: $.resultSignature\n              subStatus: $.resultType\n              durationMs: $.durationMs\n              properties: $.properties\n              entity: $.properties.entity\n              requestBody: $.properties.requestbody\n              resourceType: \"Microsoft.Authorization/roleAssignments\"\n              resourceProviderName: \"Microsoft.Authorization\"\n  query: |\n    MATCH (r:RoleAssignment)\n    RETURN r.correlationId AS correlationId,\n           r.time AS timestamp,\n           r.resourceId AS resourceId,\n           r.operationName AS operationName,\n           r.operationType AS operationType,\n           r.category AS category,\n           r.level AS level,\n           r.callerIpAddress AS callerIpAddress,\n           r.caller AS caller,\n           r.tenantId AS tenantId,\n           r.subscriptionId AS subscriptionId,\n           r.status AS status,\n           r.subStatus AS subStatus,\n           r.durationMs AS durationMs,\n           r.properties AS properties,\n           r.entity AS entity,\n           r.resourceType AS resourceType,\n           r.resourceProviderName AS resourceProviderName,\n           r.requestBody AS requestBody\n"})}),"\n",(0,i.jsx)(n.h2,{id:"-understanding-the-continuous-query-logic",children:"\ud83e\udde0 Understanding the Continuous Query Logic"}),"\n",(0,i.jsx)(n.p,{children:"This configuration leverages Drasi's event-driven streaming capabilities to track and analyze Azure role assignment changes in real time. Let's walk through what's happening:"}),"\n",(0,i.jsxs)(n.p,{children:["The file starts by declaring a ",(0,i.jsx)(n.code,{children:"ContinuousQuery"})," named ",(0,i.jsx)(n.code,{children:"azure-role-change-vmadminlogin"}),". This tells Drasi to continuously process incoming data streams for relevant events. It then connects to an Azure Event Hub source (",(0,i.jsx)(n.code,{children:"drasieventhub1"}),") that streams Azure activity logs. The pipeline extracts only those records where the operation is either a role assignment creation (",(0,i.jsx)(n.code,{children:"WRITE"}),") or deletion (",(0,i.jsx)(n.code,{children:"DELETE"}),")."]}),"\n",(0,i.jsxs)(n.p,{children:["A middleware step called ",(0,i.jsx)(n.code,{children:"extract-role-assignments"})," uses JSONPath selectors to:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Filter for role assignment events."}),"\n",(0,i.jsx)(n.li,{children:"Extract key properties such as timestamp, resource ID, operation details, caller identity, IP address, tenant and subscription IDs, and more."}),"\n",(0,i.jsxs)(n.li,{children:["Label each event as a ",(0,i.jsx)(n.code,{children:"RoleAssignment"})," node for downstream querying."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The core query than matches all ",(0,i.jsx)(n.code,{children:"RoleAssignment"})," nodes and returns a rich set of fields for each event, including:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Correlation and resource IDs"}),"\n",(0,i.jsx)(n.li,{children:"Operation details (name, type, status)"}),"\n",(0,i.jsx)(n.li,{children:"Caller and network information"}),"\n",(0,i.jsx)(n.li,{children:"Entity and resource metadata"}),"\n",(0,i.jsx)(n.li,{children:"Raw request body for further analysis"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["It is worth calling out - that the key: $.time line under the extract-role-assignments middleware specifies that the event's timestamp (from the $.time field in each Azure log record) is used as the unique key for each extracted RoleAssignment node. Using the time as a key helps Drasi maintain a consistent view of the data stream, ensuring that each event is processed only once - the problem with using the correlationId as the key is that it is not unique, and can be reused for multiple events, ie the status of a Role back assignment goes from Created, Started, Success and each of these events share the same correlationId, which overwrites the previous event in the graph - and not all statuses have the same properties ",(0,i.jsx)(n.em,{children:"(ie role definition Id which we need as part of our filtering in the Function App later on)"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"drasi apply -f azure-role-change-vmadminlogin.yaml\n"})}),"\n",(0,i.jsx)(n.p,{children:"Then check the status of the query:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"drasi list query\n# Output should show the query is Running. Any errors, such as syntax in the query, will be displayed here in the Error Message column.\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Drasi Continuous Query",src:t(1416).A+"",width:"1739",height:"883"})}),"\n",(0,i.jsx)(n.h2,{id:"-creating-the-event-grid-reaction",children:"\u26a1 Creating the Event Grid Reaction"}),"\n",(0,i.jsx)(n.p,{children:"Now that we have our source and continuous query configured, we can create our Drasi reaction. This is the action that will be taken when a role assignment event is detected. In this case, we will use an Azure Event Grid, which will send a notification to our Azure Function when a role assignment event is detected that matches our query.\nTo do this, we will create a Drasi reaction that subscribes to our continuous query, and sends a notification to our Event Grid topic. Make sure that the query matches the name of the Continous query you want it to respond to and the Event Grid URI and Key are updated to match your Event Grid topic."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",metastring:'title="azure-role-assignment-eventgrid-reaction.yaml"',children:"kind: Reaction\napiVersion: v1\nname: my-reactionvmlogin\nspec:\n  kind: EventGrid\n  queries:\n    azure-role-change-vmadminlogin:\n  properties: \n    eventGridUri: https://drasi-eventgrid-topic.newzealandnorth-1.eventgrid.azure.net/api/events\n    eventGridKey: 95zOYGFPN8rl3XlbgN00YFPSSl4wcM6FN0z9ootjSlYmUFIzKvkoJQQJ99BFACkRTxVXJ3w3AAABAZEGPUfe\n    format: unpacked\n"})}),"\n",(0,i.jsxs)(n.p,{children:["You can also use Entra ID authenticate to connect to the Event Grid topic, but for simplicity ",(0,i.jsx)(n.em,{children:"(and I was also testing this in a docker build of Drasi, so its good to highlight different methods to connect)"}),", I am using a shared access key in this example."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"drasi apply -f azure-role-assignment-eventgrid-reaction.yaml\n"})}),"\n",(0,i.jsx)(n.p,{children:"Then check the status of the query:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"drasi list reaction\n# Output should show the query is Available. \n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Drasi Reaction",src:t(33137).A+"",width:"1739",height:"883"})}),"\n",(0,i.jsx)(n.h2,{id:"-building-the-azure-function-app",children:"\ud83d\udd27 Building the Azure Function App"}),"\n",(0,i.jsxs)(n.p,{children:["Now we have our Drasi source, continuous query, and reaction configured, it's time to move to our Azure Function. This function will be triggered by the Event Grid notification when a role assignment event is detected that matches our query. The function will then create or delete the Azure Bastion host based on the role assignment event.\nThe Azure Function is written in PowerShell and uses the Azure PowerShell module to create and delete the Azure Bastion host. The function will check the operation type of the role assignment event, and if it is a ",(0,i.jsx)(n.code,{children:"WRITE"})," operation, it will create the Azure Bastion host. If it is a ",(0,i.jsx)(n.code,{children:"DELETE"})," operation, it will delete the Azure Bastion host. You can add some additional logic here around additional checks, such as checking if the role assignment is for a specific user, or adding additional roles."]}),"\n",(0,i.jsxs)(n.p,{children:["The Function App code is configured to use the system-managed identity of the Function App, which is assigned the ",(0,i.jsx)(n.code,{children:"Contributor"})," role on the Subscription where the Azure Bastion host will be created. This allows the function to create and delete the Azure Bastion host without needing to store any credentials in the function code."]}),"\n",(0,i.jsx)(n.p,{children:"The Function App is configured to be expandable:"}),"\n",(0,i.jsx)(n.h2,{id:"-function-app-architecture",children:"\ud83d\udcdd Function App Architecture"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["The entry point is ",(0,i.jsx)(n.code,{children:"run.ps1"}),", receives Event Grid results, and orchestrates the response."]}),"\n",(0,i.jsxs)(n.li,{children:["It then parses it to an ",(0,i.jsx)(n.code,{children:"EventProcessor.ps1"}),", which then handles the event processing logic."]}),"\n",(0,i.jsxs)(n.li,{children:["After the logic matches the event, it calls ",(0,i.jsx)(n.code,{children:"ActionHandlers.ps1"})," to create or delete the Azure Bastion host."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"With a config.json file to store the configuration settings for the Function App, such as the Azure Bastion host name, resource group name, location, and subscription to target, these values will be used by the ActionHandlers to create/delete the Bastion resource in the specific subscription/resource group you want."}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["You can find the complete code for the Function App and Drasi queries here: ",(0,i.jsx)(n.a,{href:"https://github.com/lukemurraynz/Drasi-RoleAssignmentMonitor",children:"lukemurraynz/Drasi-RoleAssignmentMonitor"}),"."]})}),"\n","\n",(0,i.jsxs)(s.A,{children:[(0,i.jsx)(a.A,{value:"config",label:"config.json",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",metastring:'title="config.json"',children:'{\n  "global": {\n    "enableLogging": true,\n    "defaultSubscriptionId": "6bca53bc-98d9-4cd3-92e7-0364c7bffac4",\n    "defaultResourceGroupName": "rg-11B74992",\n    "tags": {\n      "CreatedBy": "Drasi-AutoBastion",\n      "Purpose": "Automated-RBAC-Response"\n    }\n  },\n  "actions": {\n    "CreateBastion": {\n      "enabled": true,\n      "parameters": {\n        "bastionNamePrefix": "bastion-auto",\n        "subnetAddressPrefix": "10.0.1.0/26",\n        "publicIpNamePrefix": "pip-bastion-auto",\n        "subscriptionId": "<your-subscription-id>",\n        "resourceGroupName": "<your-resource-group>",\n        "bastionName": "<your-bastion-name>"\n      }\n    },\n    "CleanupBastion": {\n      "enabled": true,\n      "parameters": {\n        "preserveIfOtherAssignments": true,\n        "gracePeriodMinutes": 5,\n        "subscriptionId": "<your-subscription-id>",\n        "resourceGroupName": "<your-resource-group>"\n      }\n    }\n  },\n  "roleMappings": {\n    "/providers/Microsoft.Authorization/roleDefinitions/1c0163c0-47e6-4577-8991-ea5c82e286e4": "Virtual Machine Administrator Login",\n    "/providers/Microsoft.Authorization/roleDefinitions/fb879df8-f326-4884-b1cf-06f3ad86be52": "Virtual Machine User Login"\n  }\n}\n'})})}),(0,i.jsx)(a.A,{value:"run",label:"run.ps1",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-powershell",metastring:'title="run.ps1"',children:'param($eventGridEvent, $TriggerMetadata)\n\n# Handle Drasi.ControlSignal events\nif ($eventGridEvent.type -eq \'Drasi.ControlSignal\') {\n    $payload = $eventGridEvent.data.payload\n    $kind = $payload.kind\n    $source = $payload.source\n    if ($null -ne $source -and ($source -is [hashtable] -or $source -is [psobject])) {\n        $sourceStr = $source | ConvertTo-Json -Compress\n    } else {\n        $sourceStr = $source\n    }\n    Write-Host "[DRASI CONTROL SIGNAL] kind: $kind, source: $sourceStr"\n    return\n}\n\nWrite-Host "=== Starting Drasi RBAC Action Handler ==="\n$modulesPath = Join-Path $PSScriptRoot \'..\' \'Modules\'\n\nImport-Module (Join-Path $modulesPath \'Az.Accounts\' \'5.1.0\' \'Az.Accounts.psd1\') -Force\nImport-Module (Join-Path $modulesPath \'Az.Resources\' \'8.0.0\' \'Az.Resources.psd1\') -Force\nImport-Module (Join-Path $modulesPath \'Az.Network\' \'7.17.0\' \'Az.Network.psd1\') -Force\nImport-Module (Join-Path $modulesPath \'Az.Compute\' \'10.0.1\' \'Az.Compute.psd1\') -Force\n\ntry {\n    # Load required modules - look in parent directory\n    $functionDir = Split-Path $PSScriptRoot -Parent\n    $eventProcessorPath = Join-Path $functionDir "EventProcessor.ps1"\n    $actionHandlersPath = Join-Path $functionDir "ActionHandlers.ps1"\n    $configPath = Join-Path $functionDir "config.json"\n    \n    if (-not (Test-Path $eventProcessorPath)) {\n        throw "EventProcessor.ps1 not found at: $eventProcessorPath"\n    }\n    \n    if (-not (Test-Path $actionHandlersPath)) {\n        throw "ActionHandlers.ps1 not found at: $actionHandlersPath"\n    }\n    \n    if (-not (Test-Path $configPath)) {\n        throw "config.json not found at: $configPath"\n    }\n    \n    # Load modules\n    . $eventProcessorPath\n    . $actionHandlersPath\n    \n    Write-Host "[INFO] Modules loaded successfully"\n    \n    # Check authentication context\n    $currentContext = Get-AzContext -ErrorAction SilentlyContinue\n    if ($currentContext) {\n        Write-Host "[INFO] Azure authentication context found:"\n        Write-Host "  - Account: $($currentContext.Account.Id)"\n        Write-Host "  - Subscription: $($currentContext.Subscription.Name) ($($currentContext.Subscription.Id))"\n        Write-Host "  - Tenant: $($currentContext.Tenant.Id)"\n    } else {\n        Write-Warning "[WARNING] No Azure authentication context found"\n        # Try to re-authenticate using MSI\n        if ($env:MSI_SECRET) {\n            Write-Host "[INFO] Attempting to authenticate with MSI..."\n            try {\n                Disable-AzContextAutosave -Scope Process | Out-Null\n                $connectResult = Connect-AzAccount -Identity -ErrorAction Stop\n                Write-Host "[INFO] Successfully authenticated with MSI: $($connectResult.Context.Account.Id)"\n            } catch {\n                Write-Error "[ERROR] Failed to authenticate with MSI: $($_.Exception.Message)"\n            }\n        } else {\n            Write-Warning "[WARNING] No MSI_SECRET environment variable found"\n        }\n    }\n    \n    # Initialize configuration manager\n    $configManager = [ConfigurationManager]::new($configPath)\n    $globalConfig = $configManager.GetGlobalConfiguration()\n    \n    # Log event details if logging is enabled\n    if ($globalConfig.enableLogging) {\n        Write-Host "=== Event Grid Event Data ==="\n        $eventGridEvent | ConvertTo-Json -Depth 10 | Write-Host\n        \n        if ($eventGridEvent.data) {\n            Write-Host "=== Event Data ==="\n            $eventGridEvent.data | ConvertTo-Json -Depth 5 | Write-Host\n        }\n    }\n    \n    # Parse the Drasi event\n    Write-Host "[INFO] Parsing Drasi event..."\n    $parsedEvent = Parse-DrasiEvent $eventGridEvent\n    \n    if (-not $parsedEvent.isValid) {\n        Write-Warning "Event validation failed. This may not be a role assignment event."\n        Write-Host "=== Parsed Event Details ==="\n        $parsedEvent | ConvertTo-Json -Depth 10 | Write-Host\n        return\n    }\n    \n    # Log parsed event details\n    $roleName = $configManager.GetRoleName($parsedEvent.roleDefinitionId)\n    Write-Host "[INFO] Valid RBAC event detected:"\n    Write-Host "  - Role: $roleName"\n    Write-Host "  - Operation: $($parsedEvent.operationType)"\n    Write-Host "  - Scope: $($parsedEvent.scope)"\n    Write-Host "  - Principal ID: $($parsedEvent.principalId)"\n    Write-Host "  - Correlation ID: $($parsedEvent.correlationId)"\n    \n    # Initialize action orchestrator and process event\n    $orchestrator = [ActionOrchestrator]::new($configManager)\n    $results = $orchestrator.ProcessEvent($parsedEvent)\n    \n    # Log results\n    Write-Host "=== Action Results ==="\n    foreach ($result in $results) {\n        $status = if ($result.success) { "SUCCESS" } else { "FAILED" }\n        Write-Host "[$status] $($result.action): $($result.message)"\n        \n        if ($result.details -and $globalConfig.enableLogging) {\n            Write-Host "  Details: $($result.details | ConvertTo-Json -Depth 2)"\n        }\n    }\n    \n    # Summary\n    $successCount = ($results | Where-Object { $_.success }).Count\n    $totalCount = $results.Count\n    Write-Host "[INFO] Action execution completed: $successCount/$totalCount successful"\n    \n}\ncatch {\n    Write-Error "[ERROR] Function execution failed: $($_.Exception.Message)"\n    Write-Host "Stack trace: $($_.ScriptStackTrace)"\n    \n    # Still log the original event for debugging\n    Write-Host "=== Original Event (for debugging) ==="\n    $eventGridEvent | ConvertTo-Json -Depth 10 | Write-Host\n}\n\nWrite-Host "=== Drasi RBAC Action Handler Complete ==="\n'})})}),(0,i.jsx)(a.A,{value:"eventprocessor",label:"EventProcessor.ps1",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-powershell",metastring:'title="EventProcessor.ps1"',children:'# Modular action handlers for Azure resource automation\n\n# Configuration management class\nclass ConfigurationManager {\n    [hashtable]$Config\n    [string]$ConfigPath\n    \n    ConfigurationManager([string]$configPath) {\n        $this.ConfigPath = $configPath\n        $this.LoadConfiguration()\n    }\n    \n    [void] LoadConfiguration() {\n        if (Test-Path $this.ConfigPath) {\n            $configContent = Get-Content $this.ConfigPath -Raw | ConvertFrom-Json\n            $this.Config = $this.ConvertPSObjectToHashtable($configContent)\n        } else {\n            throw "Configuration file not found: $($this.ConfigPath)"\n        }\n    }\n    \n    [hashtable] ConvertPSObjectToHashtable([object]$inputObject) {\n        $output = @{}\n        if ($inputObject -is [PSCustomObject]) {\n            foreach ($property in $inputObject.PSObject.Properties) {\n                if ($property.Value -is [PSCustomObject]) {\n                    $output[$property.Name] = $this.ConvertPSObjectToHashtable($property.Value)\n                } elseif ($property.Value -is [array]) {\n                    $output[$property.Name] = @()\n                    foreach ($item in $property.Value) {\n                        if ($item -is [PSCustomObject]) {\n                            $output[$property.Name] += $this.ConvertPSObjectToHashtable($item)\n                        } else {\n                            $output[$property.Name] += $item\n                        }\n                    }\n                } else {\n                    $output[$property.Name] = $property.Value\n                }\n            }\n        } else {\n            return $inputObject\n        }\n        return $output\n    }\n    \n    [hashtable] GetGlobalConfiguration() {\n        return $this.Config.global\n    }\n    \n    [hashtable] GetActionConfiguration([string]$actionName) {\n        return $this.Config.actions.$actionName\n    }\n    \n[string] GetRoleName([string]$roleDefinitionId) {\n    if ($this.Config.roleMappings) {\n        foreach ($key in $this.Config.roleMappings.Keys) {\n            # Match if the roleDefinitionId ends with the mapping key (handles any prefix)\n            if ($roleDefinitionId -like "*$key") {\n                return $this.Config.roleMappings.$key\n            }\n        }\n    }\n    return "Unknown Role ($roleDefinitionId)"\n}\n}\n\n# Event parsing function for Drasi events\nfunction Parse-DrasiEvent {\n    param([hashtable]$eventGridEvent)\n    $result = @{\n        isValid = $false\n        operationType = $null\n        roleDefinitionId = $null\n        scope = $null\n        principalId = $null\n        correlationId = $null\n        timestamp = $null\n        callerIpAddress = $null\n        azureOperationName = $null  # Add this field\n    }\n    \n    try {\n        # Check if this is a Drasi ChangeEvent\n        if ($eventGridEvent.type -ne \'Drasi.ChangeEvent\') {\n            return $result\n        }\n        \n        $data = $eventGridEvent.data\n        if (-not $data -or -not $data.payload -or -not $data.payload.after) {\n            return $result\n        }\n        \n        $payload = $data.payload.after\n        \n        # Capture the actual Azure operation name\n        $result.azureOperationName = $payload.operationName\n        \n        # Check if this is a role assignment operation (CREATE or DELETE)\n        $isRoleWrite = $payload.operationName -eq \'MICROSOFT.AUTHORIZATION/ROLEASSIGNMENTS/WRITE\'\n        $isRoleDelete = $payload.operationName -eq \'MICROSOFT.AUTHORIZATION/ROLEASSIGNMENTS/DELETE\'\n        \n        if (-not ($isRoleWrite -or $isRoleDelete)) {\n            return $result\n        }\n        \n        $result.isValid = $true\n        $result.operationType = $data.op # \'i\' for insert/create, \'d\' for delete\n        $result.correlationId = $payload.correlationId\n        $result.timestamp = $payload.timestamp\n        $result.callerIpAddress = $payload.callerIpAddress\n        \n        if ($isRoleWrite -and $payload.properties.requestbody) {\n            # Parse the request body to get role assignment details for CREATE operations\n            $requestBody = $payload.properties.requestbody | ConvertFrom-Json\n            $result.roleDefinitionId = $requestBody.Properties.RoleDefinitionId\n            $result.scope = $requestBody.Properties.Scope\n            $result.principalId = $requestBody.Properties.PrincipalId\n        } elseif ($isRoleDelete) {\n            # For DELETE operations, extract from the resource ID and response body\n            $resourceId = $payload.resourceId\n            if ($resourceId -match \'/subscriptions/([^/]+)\') {\n                $extractedSubId = $Matches[1]\n                # Validate the subscription ID format before using it\n                if ($extractedSubId -match \'^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$\') {\n                    $result.scope = "/subscriptions/$extractedSubId"\n                } else {\n                    # If the extracted subscription ID is malformed, don\'t set scope\n                    # Let the action classes handle this using their config values\n                    Write-Warning "Extracted subscription ID \'$extractedSubId\' is not in valid GUID format, scope will be handled by action configuration"\n                }\n            }\n\n            # Try to extract role definition from response body if available\n            try {\n                # Ensure responseBody is parsed from string if needed\n                $responseBodyRaw = $payload.properties.responseBody\n                if ($responseBodyRaw -is [string]) {\n                    $responseBody = $responseBodyRaw | ConvertFrom-Json\n                } else {\n                    $responseBody = $responseBodyRaw\n                }\n                $result.roleDefinitionId = $responseBody.properties.roleDefinitionId\n                $result.principalId = $responseBody.properties.principalId\n            } catch {\n                # Fallback to VM Admin Login role assumption\n                $result.roleDefinitionId = "/providers/Microsoft.Authorization/roleDefinitions/1c0163c0-47e6-4577-8991-ea5c82e286e4"\n                $result.principalId = "unknown"\n            }\n            # Fallback values for DELETE operations without response body (if above fails)\n            if (-not $result.roleDefinitionId) {\n                $result.roleDefinitionId = "/providers/Microsoft.Authorization/roleDefinitions/1c0163c0-47e6-4577-8991-ea5c82e286e4"\n            }\n            if (-not $result.principalId) {\n                $result.principalId = "unknown"\n            }\n        }\n        \n        return $result\n    }\n    catch {\n        Write-Warning "Failed to parse Drasi event: $($_.Exception.Message)"\n        return $result\n    }\n}\n\n# Action orchestrator class\nclass ActionOrchestrator {\n    [ConfigurationManager]$ConfigManager\n    \n    ActionOrchestrator([ConfigurationManager]$configManager) {\n        $this.ConfigManager = $configManager\n    }\n    \n    [array] ProcessEvent([hashtable]$parsedEvent) {\n        $results = @()\n        $globalConfig = $this.ConfigManager.GetGlobalConfiguration()\n        \n        # Determine which actions to execute based on the event\n        $actionsToExecute = $this.DetermineActions($parsedEvent)\n        \n        if ($actionsToExecute.Count -eq 0) {\n            $results += [ActionResult]::new($true, "No actions determined for this event", @{\n                reason = "Event did not match action criteria"\n                roleDefinitionId = $parsedEvent.roleDefinitionId\n                operationType = $parsedEvent.operationType\n                azureOperationName = $parsedEvent.azureOperationName\n            })\n            return $results\n        }\n        \n        foreach ($actionName in $actionsToExecute) {\n            try {\n                $actionConfig = $this.ConfigManager.GetActionConfiguration($actionName)\n                if (-not $actionConfig) {\n                    $results += [ActionResult]::new($false, "Configuration not found for action: $actionName", @{})\n                    continue\n                }\n                \n                if (-not $actionConfig.enabled) {\n                    $results += [ActionResult]::new($true, "Action skipped (disabled): $actionName", @{\n                        action = $actionName\n                        skipped = $true\n                    })\n                    continue\n                }\n                \n                # Create action instance\n                $action = New-Action -ActionName $actionName -Config $actionConfig -GlobalConfig $globalConfig\n                \n                # Create context for action execution\n                $context = @{\n                    scope = $parsedEvent.scope\n                    principalId = $parsedEvent.principalId\n                    roleDefinitionId = $parsedEvent.roleDefinitionId\n                    operationType = $parsedEvent.operationType\n                    correlationId = $parsedEvent.correlationId\n                }\n                \n                # Execute action\n                $result = $action.Execute($context)\n                $result.Details.action = $actionName\n                $results += $result\n            }\n            catch {\n                $results += [ActionResult]::new($false, "Failed to execute action $actionName`: $($_.Exception.Message)", @{\n                    action = $actionName\n                    error = $_.Exception.Message\n                    stackTrace = $_.ScriptStackTrace\n                })\n            }\n        }\n        \n        return $results\n    }\n\n\n[array] DetermineActions([hashtable]$parsedEvent) {\n    $actions = @()\n    $globalConfig = $this.ConfigManager.GetGlobalConfiguration()\n    \n    $vmAdminLoginRoleId = "/providers/Microsoft.Authorization/roleDefinitions/1c0163c0-47e6-4577-8991-ea5c82e286e4"\n\n    # Debug: Log all relevant information\n    Write-Host "[DEBUG] DetermineActions: operationType=$($parsedEvent.operationType), azureOperationName=$($parsedEvent.azureOperationName), roleDefinitionId=$($parsedEvent.roleDefinitionId)"\n\n    # Check if this is a VM Admin Login role\n    if ($parsedEvent.roleDefinitionId -like "*$vmAdminLoginRoleId*") {\n        # Use the actual Azure operation name to determine action\n        $azureOperationName = $parsedEvent.azureOperationName\n        \n        if ($azureOperationName -like "*DELETE*") {\n            Write-Host "[DEBUG] Scheduling CleanupBastion action for DELETE operation"\n            $actions += "CleanupBastion"\n        } elseif ($azureOperationName -like "*WRITE*") {\n            Write-Host "[DEBUG] Scheduling CreateBastion action for WRITE operation"\n            $actions += "CreateBastion"\n        } else {\n            Write-Host "[DEBUG] Unknown Azure operation: $azureOperationName"\n        }\n    } else {\n        Write-Host "[DEBUG] Role $($parsedEvent.roleDefinitionId) is not VM Admin Login role"\n    }\n    \n    Write-Host "[DEBUG] Determined actions: $($actions -join \', \')"\n    return $actions\n}\n\n[string] GetAzureOperationFromEvent([hashtable]$parsedEvent) {\n    # This method should extract the actual Azure operation name from the parsed event\n    # You\'ll need to pass this information through from the original event parsing\n    # For now, we\'ll use a simplified approach and check if we have context about the operation\n    \n    # If the parsed event contains operation context, use it\n    if ($parsedEvent.ContainsKey(\'azureOperationName\')) {\n        return $parsedEvent.azureOperationName\n    }\n    \n    # Fallback: if we have a principalId of "unknown", it\'s likely a DELETE operation\n    # since DELETE operations don\'t contain the principal ID in the response\n    if ($parsedEvent.principalId -eq "unknown") {\n        return "MICROSOFT.AUTHORIZATION/ROLEASSIGNMENTS/DELETE"\n    }\n    \n    # Default to WRITE operation\n    return "MICROSOFT.AUTHORIZATION/ROLEASSIGNMENTS/WRITE"\n}\n\n\n    \n}\n\nclass ActionResult {\n    [bool]$Success\n    [string]$Message\n    [hashtable]$Details\n    \n    ActionResult([bool]$success, [string]$message, [hashtable]$details = @{}) {\n        $this.Success = $success\n        $this.Message = $message\n        $this.Details = $details\n    }\n}\n\nclass BaseAction {\n    [hashtable]$Config\n    [hashtable]$GlobalConfig\n    \n    BaseAction([hashtable]$config, [hashtable]$globalConfig) {\n        $this.Config = $config\n        $this.GlobalConfig = $globalConfig\n    }\n    \n    [ActionResult] Execute([hashtable]$context) {\n        throw "Execute method must be implemented by derived classes"\n    }\n    \n    [void] LogInfo([string]$message) {\n        if ($this.GlobalConfig.enableLogging) {\n            Write-Host "[INFO] $message"\n        }\n    }\n    \n    [void] LogWarning([string]$message) {\n        if ($this.GlobalConfig.enableLogging) {\n            Write-Warning "[WARNING] $message"\n        }\n    }\n    \n    [void] LogError([string]$message) {\n        if ($this.GlobalConfig.enableLogging) {\n            Write-Error "[ERROR] $message"\n        }\n    }\n}\n\nclass CreateBastionAction : BaseAction {\n    CreateBastionAction([hashtable]$config, [hashtable]$globalConfig) : base($config, $globalConfig) {}\n    \n    [ActionResult] Execute([hashtable]$context) {\n        $this.LogInfo("Starting CreateBastion action for scope: $($context.scope)")\n        \n        try {\n            # Extract resource information from scope\n            $resourceInfo = $this.ParseScope($context.scope)\n            if (-not $resourceInfo) {\n                return [ActionResult]::new($false, "Could not parse resource scope", @{})\n            }\n            \n            # Check if Bastion already exists\n            $existingBastion = $this.FindExistingBastion($resourceInfo.ResourceGroupName, $resourceInfo.SubscriptionId)\n            if ($existingBastion) {\n                $this.LogInfo("Bastion already exists: $($existingBastion.Name)")\n                return [ActionResult]::new($true, "Bastion already exists", @{\n                    action = "CreateBastion"\n                    existingBastion = $existingBastion.Name\n                    skipped = $true\n                })\n            }\n            \n            # Create Bastion\n            $result = $this.CreateBastion($resourceInfo)\n            \n            return [ActionResult]::new($true, "Bastion created successfully", @{\n                action = "CreateBastion"\n                bastionName = $result.Name\n                resourceGroup = $resourceInfo.ResourceGroupName\n                subscriptionId = $resourceInfo.SubscriptionId\n            })\n        }\n        catch {\n            $this.LogError("Failed to create Bastion: $($_.Exception.Message)")\n            return [ActionResult]::new($false, "Failed to create Bastion: $($_.Exception.Message)", @{\n                error = $_.Exception.Message\n            })\n        }\n    }\n    \n    [hashtable] ParseScope([string]$scope) {\n        # Always use config values - completely ignore parsed scope\n        $subscriptionId = $null\n        $resourceGroupName = $null\n\n        $this.LogInfo("ParseScope called for CreateBastion - ignoring scope parameter and using config values only")\n\n        # Debug the global config structure\n        $this.LogInfo("GlobalConfig keys: $($this.GlobalConfig.Keys -join \', \')")\n        $this.LogInfo("GlobalConfig.defaultSubscriptionId exists: $($this.GlobalConfig.ContainsKey(\'defaultSubscriptionId\'))")\n        $this.LogInfo("GlobalConfig.defaultResourceGroupName exists: $($this.GlobalConfig.ContainsKey(\'defaultResourceGroupName\'))")\n\n        # Always use global config values first (most reliable and consistent)\n        if ($this.GlobalConfig.ContainsKey(\'defaultSubscriptionId\') -and $this.GlobalConfig.defaultSubscriptionId) {\n            $subscriptionId = $this.GlobalConfig.defaultSubscriptionId\n            $this.LogInfo("Using default subscription ID from global config: $subscriptionId")\n        } elseif ($this.Config.parameters.ContainsKey(\'subscriptionId\') -and $this.Config.parameters.subscriptionId -and $this.Config.parameters.subscriptionId -ne \'<your-subscription-id>\') {\n            $subscriptionId = $this.Config.parameters.subscriptionId\n            $this.LogInfo("Using subscription ID from action config: $subscriptionId")\n        }\n\n        # Always use global config values first (most reliable and consistent)\n        if ($this.GlobalConfig.ContainsKey(\'defaultResourceGroupName\') -and $this.GlobalConfig.defaultResourceGroupName) {\n            $resourceGroupName = $this.GlobalConfig.defaultResourceGroupName\n            $this.LogInfo("Using default resource group from global config: $resourceGroupName")\n        } elseif ($this.Config.parameters.ContainsKey(\'resourceGroupName\') -and $this.Config.parameters.resourceGroupName -and $this.Config.parameters.resourceGroupName -ne \'<your-resource-group>\') {\n            $resourceGroupName = $this.Config.parameters.resourceGroupName\n            $this.LogInfo("Using resource group from action config: $resourceGroupName")\n        }\n\n        # Validate that we have both required values\n        if (-not $subscriptionId) {\n            $this.LogError("No subscription ID found in configuration")\n            $this.LogError("Global config defaultSubscriptionId: \'$($this.GlobalConfig.defaultSubscriptionId)\'")\n            $this.LogError("Action config subscriptionId: \'$($this.Config.parameters.subscriptionId)\'")\n            $this.LogError("Full GlobalConfig: $($this.GlobalConfig | ConvertTo-Json -Depth 2)")\n            return $null\n        }\n\n        if (-not $resourceGroupName) {\n            $this.LogError("No resource group name found in configuration")\n            $this.LogError("Global config defaultResourceGroupName: \'$($this.GlobalConfig.defaultResourceGroupName)\'")\n            $this.LogError("Action config resourceGroupName: \'$($this.Config.parameters.resourceGroupName)\'")\n            $this.LogError("Full GlobalConfig: $($this.GlobalConfig | ConvertTo-Json -Depth 2)")\n            return $null\n        }\n\n        # Validate subscription ID format\n        if (-not ($subscriptionId -match \'^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$\')) {\n            $this.LogError("Invalid subscription ID format in config: \'$subscriptionId\'")\n            return $null\n        }\n\n        $this.LogInfo("Successfully parsed config values for CreateBastion - Subscription: $subscriptionId, ResourceGroup: $resourceGroupName")\n        return @{\n            SubscriptionId = $subscriptionId\n            ResourceGroupName = $resourceGroupName\n        }\n    }\n    \n    [object] FindExistingBastion([string]$resourceGroupName, [string]$subscriptionId) {\n        try {\n            $this.LogInfo("Checking for existing Bastion in RG: $resourceGroupName")\n            \n            # Set context to correct subscription\n            Set-AzContext -SubscriptionId $subscriptionId -ErrorAction SilentlyContinue\n            \n            # Look for existing Bastion hosts\n            $bastions = Get-AzBastion -ResourceGroupName $resourceGroupName -ErrorAction SilentlyContinue\n            \n            return $bastions | Select-Object -First 1\n        }\n        catch {\n            $this.LogWarning("Could not check for existing Bastion: $($_.Exception.Message)")\n            return $null\n        }\n    }\n    \n    [object] CreateBastion([hashtable]$resourceInfo) {\n        $this.LogInfo("Creating Bastion in subscription: $($resourceInfo.SubscriptionId)")\n        # Set context to correct subscription\n        Set-AzContext -SubscriptionId $resourceInfo.SubscriptionId\n\n        # Ensure Resource Group exists\n        $rg = Get-AzResourceGroup -Name $resourceInfo.ResourceGroupName -ErrorAction SilentlyContinue\n        if (-not $rg) {\n            $this.LogInfo("Resource group \'$($resourceInfo.ResourceGroupName)\' does not exist. Creating it.")\n            $location = "New Zealand North"  # Default location; optionally make this configurable\n            $rg = New-AzResourceGroup -Name $resourceInfo.ResourceGroupName -Location $location -Tag $this.GlobalConfig.tags\n        } else {\n            $this.LogInfo("Resource group \'$($resourceInfo.ResourceGroupName)\' already exists.")\n            $location = $rg.Location\n        }\n\n        # Use bastionName from config if set, else generate\n        if ($this.Config.parameters.bastionName -and $this.Config.parameters.bastionName -ne \'<your-bastion-name>\') {\n            $bastionName = $this.Config.parameters.bastionName\n        } else {\n            $bastionName = "$($this.Config.parameters.bastionNamePrefix)-$(Get-Random -Maximum 9999)"\n        }\n        $publicIpName = "$($this.Config.parameters.publicIpNamePrefix)-$(Get-Random -Maximum 9999)"\n        \n        # Create or get virtual network\n        $vnet = $this.EnsureVirtualNetwork($resourceInfo.ResourceGroupName, $location)\n        \n        # Create or get Bastion subnet\n        $bastionSubnet = $this.EnsureBastionSubnet($vnet)\n        \n        # Create public IP\n        $publicIp = $this.CreatePublicIp($publicIpName, $resourceInfo.ResourceGroupName, $location)\n        \n        # Create Bastion\n        $this.LogInfo("Creating Bastion host: $bastionName")\n\n        $bastion = New-AzBastion -ResourceGroupName $resourceInfo.ResourceGroupName `\n                                 -Name $bastionName `\n                                 -PublicIpAddressRgName $resourceInfo.ResourceGroupName `\n                                 -PublicIpAddressName $publicIp.Name `\n                                 -VirtualNetworkRgName $resourceInfo.ResourceGroupName `\n                                 -VirtualNetworkName $vnet.Name `\n                                 -Sku "Standard" `\n                                 -ScaleUnit 2\n        \n        $this.LogInfo("Bastion created successfully: $($bastion.Name)")\n        return $bastion\n    }\n    \n    [object] EnsureVirtualNetwork([string]$resourceGroupName, [string]$location) {\n        # Try to find existing VNet, or create a simple one\n        $vnets = Get-AzVirtualNetwork -ResourceGroupName $resourceGroupName -ErrorAction SilentlyContinue\n        \n        if ($vnets) {\n            $this.LogInfo("Using existing VNet: $($vnets[0].Name)")\n            return $vnets[0]\n        }\n        \n        # Create a simple VNet for Bastion\n        $this.LogInfo("Creating new VNet for Bastion")\n        $vnetName = "vnet-bastion-auto-$(Get-Random -Maximum 9999)"\n        \n        $vnet = New-AzVirtualNetwork -ResourceGroupName $resourceGroupName `\n                                     -Location $location `\n                                     -Name $vnetName `\n                                     -AddressPrefix "10.0.0.0/16" `\n                                     -Tag $this.GlobalConfig.tags\n        \n        return $vnet\n    }\n    \n    [object] EnsureBastionSubnet([object]$vnet) {\n        # Check if AzureBastionSubnet exists\n        $bastionSubnet = $vnet.Subnets | Where-Object { $_.Name -eq "AzureBastionSubnet" }\n        \n        if ($bastionSubnet) {\n            $this.LogInfo("Using existing AzureBastionSubnet")\n            return $bastionSubnet\n        }\n        \n        # Create Bastion subnet\n        $this.LogInfo("Creating AzureBastionSubnet")\n        $subnetConfig = Add-AzVirtualNetworkSubnetConfig -VirtualNetwork $vnet `\n                                                         -Name "AzureBastionSubnet" `\n                                                         -AddressPrefix $this.Config.parameters.subnetAddressPrefix\n        \n        $vnet | Set-AzVirtualNetwork | Out-Null\n        \n        # Refresh VNet object\n        $updatedVnet = Get-AzVirtualNetwork -ResourceGroupName $vnet.ResourceGroupName -Name $vnet.Name\n        return $updatedVnet.Subnets | Where-Object { $_.Name -eq "AzureBastionSubnet" }\n    }\n    \n    [object] CreatePublicIp([string]$publicIpName, [string]$resourceGroupName, [string]$location) {\n        $this.LogInfo("Creating public IP: $publicIpName")\n        \n        return New-AzPublicIpAddress -ResourceGroupName $resourceGroupName `\n                                     -Location $location `\n                                     -Name $publicIpName `\n                                     -AllocationMethod Static `\n                                     -Sku Standard `\n                                     -Tag $this.GlobalConfig.tags\n    }\n}\n\nclass CleanupBastionAction : BaseAction {\n    CleanupBastionAction([hashtable]$config, [hashtable]$globalConfig) : base($config, $globalConfig) {}\n    \n    [ActionResult] Execute([hashtable]$context) {\n        $this.LogInfo("Starting CleanupBastion action for scope: $($context.scope)")\n        \n        try {\n            # Extract resource information from scope\n            $resourceInfo = $this.ParseScope($context.scope)\n            if (-not $resourceInfo) {\n                return [ActionResult]::new($false, "Could not parse resource scope", @{})\n            }\n            \n            # Check if we should preserve Bastion due to other assignments\n            if ($this.Config.parameters.preserveIfOtherAssignments) {\n                $hasOtherAssignments = $this.CheckForOtherRoleAssignments($resourceInfo)\n                if ($hasOtherAssignments) {\n                    $this.LogInfo("Preserving Bastion due to other role assignments")\n                    return [ActionResult]::new($true, "Bastion preserved due to other assignments", @{\n                        action = "CleanupBastion"\n                        preserved = $true\n                        reason = "Other role assignments exist"\n                    })\n                }\n            }\n            \n            # Find and remove Bastion\n            $result = $this.RemoveBastion($resourceInfo)\n            \n            return [ActionResult]::new($true, "Bastion cleanup completed", @{\n                action = "CleanupBastion"\n                removed = $result.Removed\n                bastionName = $result.BastionName\n            })\n        }\n        catch {\n            $this.LogError("Failed to cleanup Bastion: $($_.Exception.Message)")\n            return [ActionResult]::new($false, "Failed to cleanup Bastion: $($_.Exception.Message)", @{\n                error = $_.Exception.Message\n            })\n        }\n    }\n    \n    [hashtable] ParseScope([string]$scope) {\n        # Always use config values - completely ignore parsed scope  \n        $subscriptionId = $null\n        $resourceGroupName = $null\n\n        $this.LogInfo("ParseScope called for CleanupBastion - ignoring scope parameter and using config values only")\n\n        # Debug the global config structure\n        $this.LogInfo("GlobalConfig keys: $($this.GlobalConfig.Keys -join \', \')")\n        $this.LogInfo("GlobalConfig.defaultSubscriptionId exists: $($this.GlobalConfig.ContainsKey(\'defaultSubscriptionId\'))")\n        $this.LogInfo("GlobalConfig.defaultResourceGroupName exists: $($this.GlobalConfig.ContainsKey(\'defaultResourceGroupName\'))")\n\n        # Always use global config values first (most reliable and consistent)\n        if ($this.GlobalConfig.ContainsKey(\'defaultSubscriptionId\') -and $this.GlobalConfig.defaultSubscriptionId) {\n            $subscriptionId = $this.GlobalConfig.defaultSubscriptionId\n            $this.LogInfo("Using default subscription ID from global config: $subscriptionId")\n        } elseif ($this.Config.parameters.ContainsKey(\'subscriptionId\') -and $this.Config.parameters.subscriptionId -and $this.Config.parameters.subscriptionId -ne \'<your-subscription-id>\') {\n            $subscriptionId = $this.Config.parameters.subscriptionId\n            $this.LogInfo("Using subscription ID from action config: $subscriptionId")\n        }\n\n        # Always use global config values first (most reliable and consistent)\n        if ($this.GlobalConfig.ContainsKey(\'defaultResourceGroupName\') -and $this.GlobalConfig.defaultResourceGroupName) {\n            $resourceGroupName = $this.GlobalConfig.defaultResourceGroupName\n            $this.LogInfo("Using default resource group from global config: $resourceGroupName")\n        } elseif ($this.Config.parameters.ContainsKey(\'resourceGroupName\') -and $this.Config.parameters.resourceGroupName -and $this.Config.parameters.resourceGroupName -ne \'<your-resource-group>\') {\n            $resourceGroupName = $this.Config.parameters.resourceGroupName\n            $this.LogInfo("Using resource group from action config: $resourceGroupName")\n        }\n\n        # Validate that we have both required values\n        if (-not $subscriptionId) {\n            $this.LogError("No subscription ID found in configuration")\n            $this.LogError("Global config defaultSubscriptionId: \'$($this.GlobalConfig.defaultSubscriptionId)\'")\n            $this.LogError("Action config subscriptionId: \'$($this.Config.parameters.subscriptionId)\'")\n            $this.LogError("Full GlobalConfig: $($this.GlobalConfig | ConvertTo-Json -Depth 2)")\n            return $null\n        }\n\n        if (-not $resourceGroupName) {\n            $this.LogError("No resource group name found in configuration")\n            $this.LogError("Global config defaultResourceGroupName: \'$($this.GlobalConfig.defaultResourceGroupName)\'")\n            $this.LogError("Action config resourceGroupName: \'$($this.Config.parameters.resourceGroupName)\'")\n            $this.LogError("Full GlobalConfig: $($this.GlobalConfig | ConvertTo-Json -Depth 2)")\n            return $null\n        }\n\n        # Validate subscription ID format\n        if (-not ($subscriptionId -match \'^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$\')) {\n            $this.LogError("Invalid subscription ID format in config: \'$subscriptionId\'")\n            return $null\n        }\n\n        $this.LogInfo("Successfully parsed config values for CleanupBastion - Subscription: $subscriptionId, ResourceGroup: $resourceGroupName")\n        return @{\n            SubscriptionId = $subscriptionId\n            ResourceGroupName = $resourceGroupName\n        }\n    }\n    \n    [bool] CheckForOtherRoleAssignments([hashtable]$resourceInfo) {\n        # In a real implementation, you would check for other VM admin role assignments\n        # For now, return false to allow cleanup\n        $this.LogInfo("Checking for other role assignments (simplified implementation)")\n        return $false\n    }\n    \n    [hashtable] RemoveBastion([hashtable]$resourceInfo) {\n        try {\n            $this.LogInfo("RemoveBastion called with SubscriptionId: $($resourceInfo.SubscriptionId), ResourceGroupName: $($resourceInfo.ResourceGroupName)")\n            \n            # Validate inputs with detailed error messages\n            if (-not $resourceInfo) {\n                throw "Resource info is null"\n            }\n            if (-not $resourceInfo.ContainsKey(\'SubscriptionId\') -or -not $resourceInfo.SubscriptionId) {\n                throw "Subscription ID is null or empty. ResourceInfo keys: $($resourceInfo.Keys -join \', \')"\n            }\n            if (-not $resourceInfo.ContainsKey(\'ResourceGroupName\') -or -not $resourceInfo.ResourceGroupName) {\n                throw "Resource Group Name is null or empty. ResourceInfo keys: $($resourceInfo.Keys -join \', \')"\n            }\n            \n            # Validate subscription ID format\n            if (-not ($resourceInfo.SubscriptionId -match \'^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$\')) {\n                throw "Invalid subscription ID format: $($resourceInfo.SubscriptionId)"\n            }\n            \n            # Check current context first\n            $currentContext = Get-AzContext -ErrorAction SilentlyContinue\n            if ($currentContext) {\n                $this.LogInfo("Current Azure context: Subscription=$($currentContext.Subscription.Id), Account=$($currentContext.Account.Id)")\n                \n                # If we\'re already in the correct subscription, don\'t change context\n                if ($currentContext.Subscription.Id -eq $resourceInfo.SubscriptionId) {\n                    $this.LogInfo("Already in correct subscription context, skipping Set-AzContext")\n                } else {\n                    $this.LogInfo("Need to switch from subscription $($currentContext.Subscription.Id) to $($resourceInfo.SubscriptionId)")\n                    # Set context to correct subscription with proper error handling\n                    try {\n                        $context = Set-AzContext -SubscriptionId $resourceInfo.SubscriptionId -ErrorAction Stop\n                        $this.LogInfo("Successfully set Azure context to subscription: $($context.Subscription.Name) ($($context.Subscription.Id))")\n                    } catch {\n                        # If setting by subscription ID fails, try to list available subscriptions for debugging\n                        try {\n                            $this.LogInfo("Failed to set context to subscription $($resourceInfo.SubscriptionId). Listing available subscriptions:")\n                            $availableSubscriptions = Get-AzSubscription -ErrorAction SilentlyContinue\n                            if ($availableSubscriptions) {\n                                foreach ($sub in $availableSubscriptions) {\n                                    $this.LogInfo("Available subscription: $($sub.Name) ($($sub.Id))")\n                                }\n                            } else {\n                                $this.LogWarning("No subscriptions found or unable to list subscriptions")\n                            }\n                        } catch {\n                            $this.LogWarning("Unable to list subscriptions: $($_.Exception.Message)")\n                        }\n                        throw "Failed to set Azure context for subscription $($resourceInfo.SubscriptionId): $($_.Exception.Message)"\n                    }\n                }\n            } else {\n                $this.LogWarning("No current Azure context found - attempting to authenticate with MSI")\n                try {\n                    # Try to re-authenticate using MSI if no context exists\n                    if ($env:MSI_SECRET) {\n                        Disable-AzContextAutosave -Scope Process | Out-Null\n                        $connectResult = Connect-AzAccount -Identity -ErrorAction Stop\n                        $this.LogInfo("Successfully re-authenticated with MSI: $($connectResult.Context.Account.Id)")\n                        \n                        # Now set the subscription context\n                        $context = Set-AzContext -SubscriptionId $resourceInfo.SubscriptionId -ErrorAction Stop\n                        $this.LogInfo("Successfully set Azure context to subscription: $($context.Subscription.Name) ($($context.Subscription.Id))")\n                    } else {\n                        throw "No MSI_SECRET environment variable found and no current context"\n                    }\n                } catch {\n                    throw "Failed to authenticate: $($_.Exception.Message)"\n                }\n            }\n        }\n        catch {\n            $errorMsg = "Failed to set Azure context for subscription $($resourceInfo.SubscriptionId): $($_.Exception.Message)"\n            $this.LogError($errorMsg)\n            return @{ Removed = $false; BastionName = $null; Error = $errorMsg }\n        }\n        \n        try {\n            # Find Bastion hosts\n            $this.LogInfo("Looking for Bastion hosts in resource group: $($resourceInfo.ResourceGroupName)")\n            $bastions = Get-AzBastion -ResourceGroupName $resourceInfo.ResourceGroupName -ErrorAction SilentlyContinue\n            \n            if (-not $bastions) {\n                $this.LogInfo("No Bastion hosts found to remove")\n                return @{ Removed = $false; BastionName = $null; PublicIpRemoved = $false; PublicIpName = $null }\n            }\n            \n            $this.LogInfo("Found $($bastions.Count) Bastion host(s)")\n            \n            # Look for auto-created bastions first, otherwise take the first one\n            $bastionToRemove = $bastions | Where-Object { $_.Name -like "*auto*" } | Select-Object -First 1\n            if (-not $bastionToRemove) {\n                $bastionToRemove = $bastions | Select-Object -First 1\n                $this.LogInfo("No auto-created Bastion found, will remove first available: $($bastionToRemove.Name)")\n            } else {\n                $this.LogInfo("Found auto-created Bastion to remove: $($bastionToRemove.Name)")\n            }\n            \n            $publicIpRemoved = $false\n            $publicIpName = $null\n            \n            # Get the public IP resource ID from the Bastion\'s IP configuration\n            if ($bastionToRemove.IpConfigurations -and $bastionToRemove.IpConfigurations.Count -gt 0) {\n                $publicIpId = $bastionToRemove.IpConfigurations[0].PublicIpAddress.Id\n                if ($publicIpId) {\n                    $publicIpName = ($publicIpId -split "/")[-1]\n                    $this.LogInfo("Associated Public IP found: $publicIpName")\n                }\n            }\n            \n            # Remove Bastion\n            $this.LogInfo("Removing Bastion: $($bastionToRemove.Name)")\n            Remove-AzBastion -ResourceGroupName $resourceInfo.ResourceGroupName -Name $bastionToRemove.Name -Force -ErrorAction Stop\n            $this.LogInfo("Successfully removed Bastion: $($bastionToRemove.Name)")\n            \n            # Remove the associated Public IP if found\n            if ($publicIpName) {\n                try {\n                    $this.LogInfo("Removing associated Public IP: $publicIpName")\n                    Remove-AzPublicIpAddress -ResourceGroupName $resourceInfo.ResourceGroupName -Name $publicIpName -Force -ErrorAction Stop\n                    $publicIpRemoved = $true\n                    $this.LogInfo("Successfully removed Public IP: $publicIpName")\n                }\n                catch {\n                    $this.LogWarning("Failed to remove Public IP $publicIpName`: $($_.Exception.Message)")\n                }\n            }\n            \n            return @{ \n                Removed = $true; \n                BastionName = $bastionToRemove.Name; \n                PublicIpRemoved = $publicIpRemoved; \n                PublicIpName = $publicIpName \n            }\n        }\n        catch {\n            $errorMsg = "Failed to remove Bastion: $($_.Exception.Message)"\n            $this.LogError($errorMsg)\n            return @{ Removed = $false; BastionName = $null; Error = $errorMsg }\n        }\n    }\n}\n\n# Action factory function\nfunction New-Action {\n    param(\n        [string]$ActionName,\n        [hashtable]$Config,\n        [hashtable]$GlobalConfig\n    )\n    \n    switch ($ActionName) {\n        "CreateBastion" { \n            return [CreateBastionAction]::new($Config, $GlobalConfig) \n        }\n        "CleanupBastion" { \n            return [CleanupBastionAction]::new($Config, $GlobalConfig) \n        }\n        default { \n            throw "Unknown action: $ActionName" \n        }\n    }\n}\n'})})}),(0,i.jsx)(a.A,{value:"actionhandlers",label:"ActionHandlers.ps1",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-powershell",metastring:'title="ActionHandlers.ps1"',children:'# Modular action handlers for Azure resource automation\n\nclass ActionResult {\n    [bool]$Success\n    [string]$Message\n    [hashtable]$Details\n    \n    ActionResult([bool]$success, [string]$message, [hashtable]$details = @{}) {\n        $this.Success = $success\n        $this.Message = $message\n        $this.Details = $details\n    }\n}\n\nclass BaseAction {\n    [hashtable]$Config\n    [hashtable]$GlobalConfig\n    \n    BaseAction([hashtable]$config, [hashtable]$globalConfig) {\n        $this.Config = $config\n        $this.GlobalConfig = $globalConfig\n    }\n    \n    [ActionResult] Execute([hashtable]$context) {\n        throw "Execute method must be implemented by derived classes"\n    }\n    \n    [void] LogInfo([string]$message) {\n        if ($this.GlobalConfig.enableLogging) {\n            Write-Host "[INFO] $message"\n        }\n    }\n    \n    [void] LogWarning([string]$message) {\n        if ($this.GlobalConfig.enableLogging) {\n            Write-Warning "[WARNING] $message"\n        }\n    }\n    \n    [void] LogError([string]$message) {\n        if ($this.GlobalConfig.enableLogging) {\n            Write-Error "[ERROR] $message"\n        }\n    }\n}\n\nclass CreateBastionAction : BaseAction {\n    CreateBastionAction([hashtable]$config, [hashtable]$globalConfig) : base($config, $globalConfig) {}\n    \n    [ActionResult] Execute([hashtable]$context) {\n        $this.LogInfo("Starting CreateBastion action for scope: $($context.scope)")\n        \n        try {\n            # Extract resource information from scope\n            $resourceInfo = $this.ParseScope($context.scope)\n            if (-not $resourceInfo) {\n                return [ActionResult]::new($false, "Could not parse resource scope", @{})\n            }\n            \n            # Check if Bastion already exists\n            $existingBastion = $this.FindExistingBastion($resourceInfo.ResourceGroupName, $resourceInfo.SubscriptionId)\n            if ($existingBastion) {\n                $this.LogInfo("Bastion already exists: $($existingBastion.Name)")\n                return [ActionResult]::new($true, "Bastion already exists", @{\n                    action = "CreateBastion"\n                    existingBastion = $existingBastion.Name\n                    skipped = $true\n                })\n            }\n            \n            # Create Bastion\n            $result = $this.CreateBastion($resourceInfo)\n            \n            return [ActionResult]::new($true, "Bastion created successfully", @{\n                action = "CreateBastion"\n                bastionName = $result.Name\n                resourceGroup = $resourceInfo.ResourceGroupName\n                subscriptionId = $resourceInfo.SubscriptionId\n            })\n        }\n        catch {\n            $this.LogError("Failed to create Bastion: $($_.Exception.Message)")\n            return [ActionResult]::new($false, "Failed to create Bastion: $($_.Exception.Message)", @{\n                error = $_.Exception.Message\n            })\n        }\n    }\n    \n    [hashtable] ParseScope([string]$scope) {\n        # Always use config values - completely ignore parsed scope\n        $subscriptionId = $null\n        $resourceGroupName = $null\n\n        $this.LogInfo("ParseScope called for CreateBastion - ignoring scope parameter and using config values only")\n\n        # Debug the global config structure\n        $this.LogInfo("GlobalConfig keys: $($this.GlobalConfig.Keys -join \', \')")\n        $this.LogInfo("GlobalConfig.defaultSubscriptionId exists: $($this.GlobalConfig.ContainsKey(\'defaultSubscriptionId\'))")\n        $this.LogInfo("GlobalConfig.defaultResourceGroupName exists: $($this.GlobalConfig.ContainsKey(\'defaultResourceGroupName\'))")\n\n        # Always use global config values first (most reliable and consistent)\n        if ($this.GlobalConfig.ContainsKey(\'defaultSubscriptionId\') -and $this.GlobalConfig.defaultSubscriptionId) {\n            $subscriptionId = $this.GlobalConfig.defaultSubscriptionId\n            $this.LogInfo("Using default subscription ID from global config: $subscriptionId")\n        } elseif ($this.Config.parameters.ContainsKey(\'subscriptionId\') -and $this.Config.parameters.subscriptionId -and $this.Config.parameters.subscriptionId -ne \'<your-subscription-id>\') {\n            $subscriptionId = $this.Config.parameters.subscriptionId\n            $this.LogInfo("Using subscription ID from action config: $subscriptionId")\n        }\n\n        # Always use global config values first (most reliable and consistent)\n        if ($this.GlobalConfig.ContainsKey(\'defaultResourceGroupName\') -and $this.GlobalConfig.defaultResourceGroupName) {\n            $resourceGroupName = $this.GlobalConfig.defaultResourceGroupName\n            $this.LogInfo("Using default resource group from global config: $resourceGroupName")\n        } elseif ($this.Config.parameters.ContainsKey(\'resourceGroupName\') -and $this.Config.parameters.resourceGroupName -and $this.Config.parameters.resourceGroupName -ne \'<your-resource-group>\') {\n            $resourceGroupName = $this.Config.parameters.resourceGroupName\n            $this.LogInfo("Using resource group from action config: $resourceGroupName")\n        }\n\n        # Validate that we have both required values\n        if (-not $subscriptionId) {\n            $this.LogError("No subscription ID found in configuration")\n            $this.LogError("Global config defaultSubscriptionId: \'$($this.GlobalConfig.defaultSubscriptionId)\'")\n            $this.LogError("Action config subscriptionId: \'$($this.Config.parameters.subscriptionId)\'")\n            $this.LogError("Full GlobalConfig: $($this.GlobalConfig | ConvertTo-Json -Depth 2)")\n            return $null\n        }\n\n        if (-not $resourceGroupName) {\n            $this.LogError("No resource group name found in configuration")\n            $this.LogError("Global config defaultResourceGroupName: \'$($this.GlobalConfig.defaultResourceGroupName)\'")\n            $this.LogError("Action config resourceGroupName: \'$($this.Config.parameters.resourceGroupName)\'")\n            $this.LogError("Full GlobalConfig: $($this.GlobalConfig | ConvertTo-Json -Depth 2)")\n            return $null\n        }\n\n        # Validate subscription ID format\n        if (-not ($subscriptionId -match \'^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$\')) {\n            $this.LogError("Invalid subscription ID format in config: \'$subscriptionId\'")\n            return $null\n        }\n\n        $this.LogInfo("Successfully parsed config values for CreateBastion - Subscription: $subscriptionId, ResourceGroup: $resourceGroupName")\n        return @{\n            SubscriptionId = $subscriptionId\n            ResourceGroupName = $resourceGroupName\n        }\n    }\n    \n    [object] FindExistingBastion([string]$resourceGroupName, [string]$subscriptionId) {\n        try {\n            $this.LogInfo("Checking for existing Bastion in RG: $resourceGroupName")\n            \n            # Set context to correct subscription\n            Set-AzContext -SubscriptionId $subscriptionId -ErrorAction SilentlyContinue\n            \n            # Look for existing Bastion hosts\n            $bastions = Get-AzBastion -ResourceGroupName $resourceGroupName -ErrorAction SilentlyContinue\n            \n            return $bastions | Select-Object -First 1\n        }\n        catch {\n            $this.LogWarning("Could not check for existing Bastion: $($_.Exception.Message)")\n            return $null\n        }\n    }\n    \n    [object] CreateBastion([hashtable]$resourceInfo) {\n        $this.LogInfo("Creating Bastion in subscription: $($resourceInfo.SubscriptionId)")\n        # Set context to correct subscription\n        Set-AzContext -SubscriptionId $resourceInfo.SubscriptionId\n\n        # Ensure Resource Group exists\n        $rg = Get-AzResourceGroup -Name $resourceInfo.ResourceGroupName -ErrorAction SilentlyContinue\n        if (-not $rg) {\n            $this.LogInfo("Resource group \'$($resourceInfo.ResourceGroupName)\' does not exist. Creating it.")\n            $location = "New Zealand North"  # Default location; optionally make this configurable\n            $rg = New-AzResourceGroup -Name $resourceInfo.ResourceGroupName -Location $location -Tag $this.GlobalConfig.tags\n        } else {\n            $this.LogInfo("Resource group \'$($resourceInfo.ResourceGroupName)\' already exists.")\n            $location = $rg.Location\n        }\n\n        # Use bastionName from config if set, else generate\n        if ($this.Config.parameters.bastionName -and $this.Config.parameters.bastionName -ne \'<your-bastion-name>\') {\n            $bastionName = $this.Config.parameters.bastionName\n        } else {\n            $bastionName = "$($this.Config.parameters.bastionNamePrefix)-$(Get-Random -Maximum 9999)"\n        }\n        $publicIpName = "$($this.Config.parameters.publicIpNamePrefix)-$(Get-Random -Maximum 9999)"\n        \n        # Create or get virtual network\n        $vnet = $this.EnsureVirtualNetwork($resourceInfo.ResourceGroupName, $location)\n        \n        # Create or get Bastion subnet\n        $bastionSubnet = $this.EnsureBastionSubnet($vnet)\n        \n        # Create public IP\n        $publicIp = $this.CreatePublicIp($publicIpName, $resourceInfo.ResourceGroupName, $location)\n        \n        # Create Bastion\n        $this.LogInfo("Creating Bastion host: $bastionName")\n\n        $bastion = New-AzBastion -ResourceGroupName $resourceInfo.ResourceGroupName `\n                                 -Name $bastionName `\n                                 -PublicIpAddressRgName $resourceInfo.ResourceGroupName `\n                                 -PublicIpAddressName $publicIp.Name `\n                                 -VirtualNetworkRgName $resourceInfo.ResourceGroupName `\n                                 -VirtualNetworkName $vnet.Name `\n                                 -Sku "Standard" `\n                                 -ScaleUnit 2\n        \n        $this.LogInfo("Bastion created successfully: $($bastion.Name)")\n        return $bastion\n    }\n    \n    [object] EnsureVirtualNetwork([string]$resourceGroupName, [string]$location) {\n        # Try to find existing VNet, or create a simple one\n        $vnets = Get-AzVirtualNetwork -ResourceGroupName $resourceGroupName -ErrorAction SilentlyContinue\n        \n        if ($vnets) {\n            $this.LogInfo("Using existing VNet: $($vnets[0].Name)")\n            return $vnets[0]\n        }\n        \n        # Create a simple VNet for Bastion\n        $this.LogInfo("Creating new VNet for Bastion")\n        $vnetName = "vnet-bastion-auto-$(Get-Random -Maximum 9999)"\n        \n        $vnet = New-AzVirtualNetwork -ResourceGroupName $resourceGroupName `\n                                     -Location $location `\n                                     -Name $vnetName `\n                                     -AddressPrefix "10.0.0.0/16" `\n                                     -Tag $this.GlobalConfig.tags\n        \n        return $vnet\n    }\n    \n    [object] EnsureBastionSubnet([object]$vnet) {\n        # Check if AzureBastionSubnet exists\n        $bastionSubnet = $vnet.Subnets | Where-Object { $_.Name -eq "AzureBastionSubnet" }\n        \n        if ($bastionSubnet) {\n            $this.LogInfo("Using existing AzureBastionSubnet")\n            return $bastionSubnet\n        }\n        \n        # Create Bastion subnet\n        $this.LogInfo("Creating AzureBastionSubnet")\n        $subnetConfig = Add-AzVirtualNetworkSubnetConfig -VirtualNetwork $vnet `\n                                                         -Name "AzureBastionSubnet" `\n                                                         -AddressPrefix $this.Config.parameters.subnetAddressPrefix\n        \n        $vnet | Set-AzVirtualNetwork | Out-Null\n        \n        # Refresh VNet object\n        $updatedVnet = Get-AzVirtualNetwork -ResourceGroupName $vnet.ResourceGroupName -Name $vnet.Name\n        return $updatedVnet.Subnets | Where-Object { $_.Name -eq "AzureBastionSubnet" }\n    }\n    \n    [object] CreatePublicIp([string]$publicIpName, [string]$resourceGroupName, [string]$location) {\n        $this.LogInfo("Creating public IP: $publicIpName")\n        \n        return New-AzPublicIpAddress -ResourceGroupName $resourceGroupName `\n                                     -Location $location `\n                                     -Name $publicIpName `\n                                     -AllocationMethod Static `\n                                     -Sku Standard `\n                                     -Tag $this.GlobalConfig.tags\n    }\n}\n\nclass CleanupBastionAction : BaseAction {\n    CleanupBastionAction([hashtable]$config, [hashtable]$globalConfig) : base($config, $globalConfig) {}\n    \n    [ActionResult] Execute([hashtable]$context) {\n        $this.LogInfo("Starting CleanupBastion action for scope: $($context.scope)")\n        \n        try {\n            # Extract resource information from scope\n            $resourceInfo = $this.ParseScope($context.scope)\n            if (-not $resourceInfo) {\n                return [ActionResult]::new($false, "Could not parse resource scope", @{})\n            }\n            \n            # Check if we should preserve Bastion due to other assignments\n            if ($this.Config.parameters.preserveIfOtherAssignments) {\n                $hasOtherAssignments = $this.CheckForOtherRoleAssignments($resourceInfo)\n                if ($hasOtherAssignments) {\n                    $this.LogInfo("Preserving Bastion due to other role assignments")\n                    return [ActionResult]::new($true, "Bastion preserved due to other assignments", @{\n                        action = "CleanupBastion"\n                        preserved = $true\n                        reason = "Other role assignments exist"\n                    })\n                }\n            }\n            \n            # Find and remove Bastion\n            $result = $this.RemoveBastion($resourceInfo)\n            \n            return [ActionResult]::new($true, "Bastion cleanup completed", @{\n                action = "CleanupBastion"\n                removed = $result.Removed\n                bastionName = $result.BastionName\n            })\n        }\n        catch {\n            $this.LogError("Failed to cleanup Bastion: $($_.Exception.Message)")\n            return [ActionResult]::new($false, "Failed to cleanup Bastion: $($_.Exception.Message)", @{\n                error = $_.Exception.Message\n            })\n        }\n    }\n    \n    [hashtable] ParseScope([string]$scope) {\n        # Always use config values - completely ignore parsed scope  \n        $subscriptionId = $null\n        $resourceGroupName = $null\n\n        $this.LogInfo("ParseScope called for CleanupBastion - ignoring scope parameter and using config values only")\n\n        # Debug the global config structure\n        $this.LogInfo("GlobalConfig keys: $($this.GlobalConfig.Keys -join \', \')")\n        $this.LogInfo("GlobalConfig.defaultSubscriptionId exists: $($this.GlobalConfig.ContainsKey(\'defaultSubscriptionId\'))")\n        $this.LogInfo("GlobalConfig.defaultResourceGroupName exists: $($this.GlobalConfig.ContainsKey(\'defaultResourceGroupName\'))")\n\n        # Always use global config values first (most reliable and consistent)\n        if ($this.GlobalConfig.ContainsKey(\'defaultSubscriptionId\') -and $this.GlobalConfig.defaultSubscriptionId) {\n            $subscriptionId = $this.GlobalConfig.defaultSubscriptionId\n            $this.LogInfo("Using default subscription ID from global config: $subscriptionId")\n        } elseif ($this.Config.parameters.ContainsKey(\'subscriptionId\') -and $this.Config.parameters.subscriptionId -and $this.Config.parameters.subscriptionId -ne \'<your-subscription-id>\') {\n            $subscriptionId = $this.Config.parameters.subscriptionId\n            $this.LogInfo("Using subscription ID from action config: $subscriptionId")\n        }\n\n        # Always use global config values first (most reliable and consistent)\n        if ($this.GlobalConfig.ContainsKey(\'defaultResourceGroupName\') -and $this.GlobalConfig.defaultResourceGroupName) {\n            $resourceGroupName = $this.GlobalConfig.defaultResourceGroupName\n            $this.LogInfo("Using default resource group from global config: $resourceGroupName")\n        } elseif ($this.Config.parameters.ContainsKey(\'resourceGroupName\') -and $this.Config.parameters.resourceGroupName -and $this.Config.parameters.resourceGroupName -ne \'<your-resource-group>\') {\n            $resourceGroupName = $this.Config.parameters.resourceGroupName\n            $this.LogInfo("Using resource group from action config: $resourceGroupName")\n        }\n\n        # Validate that we have both required values\n        if (-not $subscriptionId) {\n            $this.LogError("No subscription ID found in configuration")\n            $this.LogError("Global config defaultSubscriptionId: \'$($this.GlobalConfig.defaultSubscriptionId)\'")\n            $this.LogError("Action config subscriptionId: \'$($this.Config.parameters.subscriptionId)\'")\n            $this.LogError("Full GlobalConfig: $($this.GlobalConfig | ConvertTo-Json -Depth 2)")\n            return $null\n        }\n\n        if (-not $resourceGroupName) {\n            $this.LogError("No resource group name found in configuration")\n            $this.LogError("Global config defaultResourceGroupName: \'$($this.GlobalConfig.defaultResourceGroupName)\'")\n            $this.LogError("Action config resourceGroupName: \'$($this.Config.parameters.resourceGroupName)\'")\n            $this.LogError("Full GlobalConfig: $($this.GlobalConfig | ConvertTo-Json -Depth 2)")\n            return $null\n        }\n\n        # Validate subscription ID format\n        if (-not ($subscriptionId -match \'^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$\')) {\n            $this.LogError("Invalid subscription ID format in config: \'$subscriptionId\'")\n            return $null\n        }\n\n        $this.LogInfo("Successfully parsed config values for CleanupBastion - Subscription: $subscriptionId, ResourceGroup: $resourceGroupName")\n        return @{\n            SubscriptionId = $subscriptionId\n            ResourceGroupName = $resourceGroupName\n        }\n    }\n    \n    [bool] CheckForOtherRoleAssignments([hashtable]$resourceInfo) {\n        # In a real implementation, you would check for other VM admin role assignments\n        # For now, return false to allow cleanup\n        $this.LogInfo("Checking for other role assignments (simplified implementation)")\n        return $false\n    }\n    \n    [hashtable] RemoveBastion([hashtable]$resourceInfo) {\n        try {\n            $this.LogInfo("RemoveBastion called with SubscriptionId: $($resourceInfo.SubscriptionId), ResourceGroupName: $($resourceInfo.ResourceGroupName)")\n            \n            # Validate inputs with detailed error messages\n            if (-not $resourceInfo) {\n                throw "Resource info is null"\n            }\n            if (-not $resourceInfo.ContainsKey(\'SubscriptionId\') -or -not $resourceInfo.SubscriptionId) {\n                throw "Subscription ID is null or empty. ResourceInfo keys: $($resourceInfo.Keys -join \', \')"\n            }\n            if (-not $resourceInfo.ContainsKey(\'ResourceGroupName\') -or -not $resourceInfo.ResourceGroupName) {\n                throw "Resource Group Name is null or empty. ResourceInfo keys: $($resourceInfo.Keys -join \', \')"\n            }\n            \n            # Validate subscription ID format\n            if (-not ($resourceInfo.SubscriptionId -match \'^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$\')) {\n                throw "Invalid subscription ID format: $($resourceInfo.SubscriptionId)"\n            }\n            \n            # Check current context first\n            $currentContext = Get-AzContext -ErrorAction SilentlyContinue\n            if ($currentContext) {\n                $this.LogInfo("Current Azure context: Subscription=$($currentContext.Subscription.Id), Account=$($currentContext.Account.Id)")\n                \n                # If we\'re already in the correct subscription, don\'t change context\n                if ($currentContext.Subscription.Id -eq $resourceInfo.SubscriptionId) {\n                    $this.LogInfo("Already in correct subscription context, skipping Set-AzContext")\n                } else {\n                    $this.LogInfo("Need to switch from subscription $($currentContext.Subscription.Id) to $($resourceInfo.SubscriptionId)")\n                    # Set context to correct subscription with proper error handling\n                    try {\n                        $context = Set-AzContext -SubscriptionId $resourceInfo.SubscriptionId -ErrorAction Stop\n                        $this.LogInfo("Successfully set Azure context to subscription: $($context.Subscription.Name) ($($context.Subscription.Id))")\n                    } catch {\n                        # If setting by subscription ID fails, try to list available subscriptions for debugging\n                        try {\n                            $this.LogInfo("Failed to set context to subscription $($resourceInfo.SubscriptionId). Listing available subscriptions:")\n                            $availableSubscriptions = Get-AzSubscription -ErrorAction SilentlyContinue\n                            if ($availableSubscriptions) {\n                                foreach ($sub in $availableSubscriptions) {\n                                    $this.LogInfo("Available subscription: $($sub.Name) ($($sub.Id))")\n                                }\n                            } else {\n                                $this.LogWarning("No subscriptions found or unable to list subscriptions")\n                            }\n                        } catch {\n                            $this.LogWarning("Unable to list subscriptions: $($_.Exception.Message)")\n                        }\n                        throw "Failed to set Azure context for subscription $($resourceInfo.SubscriptionId): $($_.Exception.Message)"\n                    }\n                }\n            } else {\n                $this.LogWarning("No current Azure context found - attempting to authenticate with MSI")\n                try {\n                    # Try to re-authenticate using MSI if no context exists\n                    if ($env:MSI_SECRET) {\n                        Disable-AzContextAutosave -Scope Process | Out-Null\n                        $connectResult = Connect-AzAccount -Identity -ErrorAction Stop\n                        $this.LogInfo("Successfully re-authenticated with MSI: $($connectResult.Context.Account.Id)")\n                        \n                        # Now set the subscription context\n                        $context = Set-AzContext -SubscriptionId $resourceInfo.SubscriptionId -ErrorAction Stop\n                        $this.LogInfo("Successfully set Azure context to subscription: $($context.Subscription.Name) ($($context.Subscription.Id))")\n                    } else {\n                        throw "No MSI_SECRET environment variable found and no current context"\n                    }\n                } catch {\n                    throw "Failed to authenticate: $($_.Exception.Message)"\n                }\n            }\n        }\n        catch {\n            $errorMsg = "Failed to set Azure context for subscription $($resourceInfo.SubscriptionId): $($_.Exception.Message)"\n            $this.LogError($errorMsg)\n            return @{ Removed = $false; BastionName = $null; Error = $errorMsg }\n        }\n        \n        try {\n            # Find Bastion hosts\n            $this.LogInfo("Looking for Bastion hosts in resource group: $($resourceInfo.ResourceGroupName)")\n            $bastions = Get-AzBastion -ResourceGroupName $resourceInfo.ResourceGroupName -ErrorAction SilentlyContinue\n            \n            if (-not $bastions) {\n                $this.LogInfo("No Bastion hosts found to remove")\n                return @{ Removed = $false; BastionName = $null; PublicIpRemoved = $false; PublicIpName = $null }\n            }\n            \n            $this.LogInfo("Found $($bastions.Count) Bastion host(s)")\n            \n            # Look for auto-created bastions first, otherwise take the first one\n            $bastionToRemove = $bastions | Where-Object { $_.Name -like "*auto*" } | Select-Object -First 1\n            if (-not $bastionToRemove) {\n                $bastionToRemove = $bastions | Select-Object -First 1\n                $this.LogInfo("No auto-created Bastion found, will remove first available: $($bastionToRemove.Name)")\n            } else {\n                $this.LogInfo("Found auto-created Bastion to remove: $($bastionToRemove.Name)")\n            }\n            \n            $publicIpRemoved = $false\n            $publicIpName = $null\n            \n            # Get the public IP resource ID from the Bastion\'s IP configuration\n            if ($bastionToRemove.IpConfigurations -and $bastionToRemove.IpConfigurations.Count -gt 0) {\n                $publicIpId = $bastionToRemove.IpConfigurations[0].PublicIpAddress.Id\n                if ($publicIpId) {\n                    $publicIpName = ($publicIpId -split "/")[-1]\n                    $this.LogInfo("Associated Public IP found: $publicIpName")\n                }\n            }\n            \n            # Remove Bastion\n            $this.LogInfo("Removing Bastion: $($bastionToRemove.Name)")\n            Remove-AzBastion -ResourceGroupName $resourceInfo.ResourceGroupName -Name $bastionToRemove.Name -Force -ErrorAction Stop\n            $this.LogInfo("Successfully removed Bastion: $($bastionToRemove.Name)")\n            \n            # Remove the associated Public IP if found\n            if ($publicIpName) {\n                try {\n                    $this.LogInfo("Removing associated Public IP: $publicIpName")\n                    Remove-AzPublicIpAddress -ResourceGroupName $resourceInfo.ResourceGroupName -Name $publicIpName -Force -ErrorAction Stop\n                    $publicIpRemoved = $true\n                    $this.LogInfo("Successfully removed Public IP: $publicIpName")\n                }\n                catch {\n                    $this.LogWarning("Failed to remove Public IP $publicIpName`: $($_.Exception.Message)")\n                }\n            }\n            \n            return @{ \n                Removed = $true; \n                BastionName = $bastionToRemove.Name; \n                PublicIpRemoved = $publicIpRemoved; \n                PublicIpName = $publicIpName \n            }\n        }\n        catch {\n            $errorMsg = "Failed to remove Bastion: $($_.Exception.Message)"\n            $this.LogError($errorMsg)\n            return @{ Removed = $false; BastionName = $null; Error = $errorMsg }\n        }\n    }\n}\n\n# Action factory function\nfunction New-Action {\n    param(\n        [string]$ActionName,\n        [hashtable]$Config,\n        [hashtable]$GlobalConfig\n    )\n    \n    switch ($ActionName) {\n        "CreateBastion" { \n            return [CreateBastionAction]::new($Config, $GlobalConfig) \n        }\n        "CleanupBastion" { \n            return [CleanupBastionAction]::new($Config, $GlobalConfig) \n        }\n        default { \n            throw "Unknown action: $ActionName" \n        }\n    }\n}\n'})})})]}),"\n",(0,i.jsx)(n.h2,{id:"-deploying-the-function-app",children:"\ud83d\ude80 Deploying the Function App"}),"\n",(0,i.jsx)(n.p,{children:"Now let's deploy our Function App to Azure. I am just going to publish directly from VS Code."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Push Azure Function App",src:t(54527).A+"",width:"1739",height:"883"})}),"\n",(0,i.jsx)(n.p,{children:"Once pushed, we need to make sure the Trigger is configured to the Event Grid topic by creating a Subscription. I will do this in the Azure Portal."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Create Event Grid Subscription",src:t(93064).A+"",width:"1893",height:"924"})}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsx)(n.p,{children:"If you get [Error] ERROR: The member 'FormatsToProcess' in the module manifest is not valid. I have found republishing the module to the Function App fixes this in the second attempt."})}),"\n",(0,i.jsx)(n.h2,{id:"-testing-the-complete-system",children:"\ud83e\uddea Testing the Complete System"}),"\n",(0,i.jsxs)(n.p,{children:["Now - lets test it, by assigning myself the Virtual Machine Administrator Login role, which will then create an ",(0,i.jsx)(n.a,{href:"https://learn.microsoft.com/azure/azure-monitor/platform/activity-log-insights?WT.mc_id=AZ-MVP-5004796",children:"Azure Activity Log"})," entry, which will get pushed to the Event Hub, which will then be picked up by Drasi, processed and flicked through to Event Grid for my ",(0,i.jsx)(n.a,{href:"https://learn.microsoft.com/azure/azure-functions/functions-overview?WT.mc_id=AZ-MVP-5004796",children:"Function App"})," to process. Make sure you set the ",(0,i.jsx)(n.a,{href:"https://learn.microsoft.com/azure/role-based-access-control/overview?WT.mc_id=AZ-MVP-5004796",children:"RBAC assignment"})," to the Subscription scope that is directing its logs to the ",(0,i.jsx)(n.a,{href:"https://learn.microsoft.com/azure/event-hubs/event-hubs-about?WT.mc_id=AZ-MVP-5004796",children:"Event Hub"}),", or it will never be picked up, you can have multiple subscriptions sending logs to the same Event Hub _(and the Region doesn't matter). Remember, there may be a delay before the event is added to the Event Hub, so please be patient. I monitor the Event Hub in the Azure Portal to track when the event arrives, using the ",(0,i.jsx)(n.a,{href:"https://learn.microsoft.com/azure/event-hubs/event-hubs-data-explorer?WT.mc_id=AZ-MVP-5004796",children:"Azure Event Hub Data Explorer"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"You can always push through an example log entry through the Event Hub directly, especially if you have a previous WRITE or DELETE event you can copy and resend to fast-track your testing. It's worth noting that Bastion can take a few minutes to create itself, be patient, but you can check its status in the Azure Portal. You could trigger a Teams notification from the Azure Function once it's completed."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Assign VM Admin Role",src:t(53918).A+"",width:"1893",height:"905"})}),"\n",(0,i.jsxs)(n.p,{children:["!",(0,i.jsx)(n.img,{alt:"Azure Function Created Bastion",src:t(76246).A+"",width:"1720",height:"579"})]}),"\n",(0,i.jsx)(n.p,{children:"Now, if we remove the old, the DELETE event will be picked up by Drasi, and the Function App will process it, removing the Bastion host and Public IP address."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Azure Function Removed Bastion",src:t(1831).A+"",width:"1893",height:"905"})})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},19365:(e,n,t)=>{t.d(n,{A:()=>s});t(96540);var o=t(34164);const i={tabItem:"tabItem_Ymn6"};var r=t(74848);function s({children:e,hidden:n,className:t}){return(0,r.jsx)("div",{role:"tabpanel",className:(0,o.A)(i.tabItem,t),hidden:n,children:e})}},11470:(e,n,t)=>{t.d(n,{A:()=>y});var o=t(96540),i=t(34164),r=t(23104),s=t(56347),a=t(205),c=t(57485),u=t(31682),l=t(70679);function d(e){return o.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,o.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function h(e){const{values:n,children:t}=e;return(0,o.useMemo)((()=>{const e=n??function(e){return d(e).map((({props:{value:e,label:n,attributes:t,default:o}})=>({value:e,label:n,attributes:t,default:o})))}(t);return function(e){const n=(0,u.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function p({value:e,tabValues:n}){return n.some((n=>n.value===e))}function g({queryString:e=!1,groupId:n}){const t=(0,s.W6)(),i=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,c.aZ)(i),(0,o.useCallback)((e=>{if(!i)return;const n=new URLSearchParams(t.location.search);n.set(i,e),t.replace({...t.location,search:n.toString()})}),[i,t])]}function $(e){const{defaultValue:n,queryString:t=!1,groupId:i}=e,r=h(e),[s,c]=(0,o.useState)((()=>function({defaultValue:e,tabValues:n}){if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!p({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const t=n.find((e=>e.default))??n[0];if(!t)throw new Error("Unexpected error: 0 tabValues");return t.value}({defaultValue:n,tabValues:r}))),[u,d]=g({queryString:t,groupId:i}),[$,f]=function({groupId:e}){const n=function(e){return e?`docusaurus.tab.${e}`:null}(e),[t,i]=(0,l.Dv)(n);return[t,(0,o.useCallback)((e=>{n&&i.set(e)}),[n,i])]}({groupId:i}),m=(()=>{const e=u??$;return p({value:e,tabValues:r})?e:null})();(0,a.A)((()=>{m&&c(m)}),[m]);return{selectedValue:s,selectValue:(0,o.useCallback)((e=>{if(!p({value:e,tabValues:r}))throw new Error(`Can't select invalid tab value=${e}`);c(e),d(e),f(e)}),[d,f,r]),tabValues:r}}var f=t(92303);const m={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var b=t(74848);function I({className:e,block:n,selectedValue:t,selectValue:o,tabValues:s}){const a=[],{blockElementScrollPositionUntilNextRender:c}=(0,r.a_)(),u=e=>{const n=e.currentTarget,i=a.indexOf(n),r=s[i].value;r!==t&&(c(n),o(r))},l=e=>{let n=null;switch(e.key){case"Enter":u(e);break;case"ArrowRight":{const t=a.indexOf(e.currentTarget)+1;n=a[t]??a[0];break}case"ArrowLeft":{const t=a.indexOf(e.currentTarget)-1;n=a[t]??a[a.length-1];break}}n?.focus()};return(0,b.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.A)("tabs",{"tabs--block":n},e),children:s.map((({value:e,label:n,attributes:o})=>(0,b.jsx)("li",{role:"tab",tabIndex:t===e?0:-1,"aria-selected":t===e,ref:e=>{a.push(e)},onKeyDown:l,onClick:u,...o,className:(0,i.A)("tabs__item",m.tabItem,o?.className,{"tabs__item--active":t===e}),children:n??e},e)))})}function v({lazy:e,children:n,selectedValue:t}){const r=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const e=r.find((e=>e.props.value===t));return e?(0,o.cloneElement)(e,{className:(0,i.A)("margin-top--md",e.props.className)}):null}return(0,b.jsx)("div",{className:"margin-top--md",children:r.map(((e,n)=>(0,o.cloneElement)(e,{key:n,hidden:e.props.value!==t})))})}function A(e){const n=$(e);return(0,b.jsxs)("div",{className:(0,i.A)("tabs-container",m.tabList),children:[(0,b.jsx)(I,{...n,...e}),(0,b.jsx)(v,{...n,...e})]})}function y(e){const n=(0,f.A)();return(0,b.jsx)(A,{...e,children:d(e.children)},String(n))}},1416:(e,n,t)=>{t.d(n,{A:()=>o});const o=t.p+"assets/images/AddEHDrasiContinousQuery-c153912d33def93c7b06156348c6b39b.gif"},33137:(e,n,t)=>{t.d(n,{A:()=>o});const o=t.p+"assets/images/AddEHDrasiEGReaction-ee4f4a57ab339b2eccf6753ce3511c29.gif"},70515:(e,n,t)=>{t.d(n,{A:()=>o});const o=t.p+"assets/images/AddEHDrasiSource-75faaaccba8b8ad7179e54272c191857.gif"},53918:(e,n,t)=>{t.d(n,{A:()=>o});const o=t.p+"assets/images/AssignVMAdminRole-9f60e032b4ab125542f30124a1327f5b.gif"},88194:(e,n,t)=>{t.d(n,{A:()=>o});const o=t.p+"assets/images/AzureActivityLogExportEventHub-90680725810b2d927c291c1fdbb1af33.gif"},83004:(e,n,t)=>{t.d(n,{A:()=>o});const o=t.p+"assets/images/AzureEventHubsDataReceiver_UIM-c60590fd110e1a86c5bc09c64804ecf9.jpg"},93064:(e,n,t)=>{t.d(n,{A:()=>o});const o=t.p+"assets/images/CreateEventGridSubscription-34c73bf306137ebd4e293198d7506e6a.gif"},76246:(e,n,t)=>{t.d(n,{A:()=>o});const o=t.p+"assets/images/FunctionCreatedBastion-4b68560552d082758fab17637e82f385.jpg"},54527:(e,n,t)=>{t.d(n,{A:()=>o});const o=t.p+"assets/images/PushDrasiReactionAzureFunctionApp-538bc7ff9b48371be06ee851c9c12937.gif"},1831:(e,n,t)=>{t.d(n,{A:()=>o});const o=t.p+"assets/images/RemoveVMAdminRole-ef07b4e8df46b71ad637f3e2416080b1.gif"},67939:(e,n,t)=>{t.d(n,{A:()=>o});const o=t.p+"assets/images/createfederateddrasisourcedredential-608bfa8e175034ae98181705b56ee0cf.gif"},78600:(e,n,t)=>{t.d(n,{A:()=>o});const o=t.p+"assets/images/drasi-simple-end-to-end-66436bc5c4205a62abde330ec232e08d.png"},11397:(e,n,t)=>{t.d(n,{A:()=>o});const o=t.p+"assets/images/drasiInitaks-cfd8bbbd8d736e5a48892d47a3de25b9.gif"},23680:(e,n,t)=>{t.d(n,{A:()=>o});const o=t.p+"assets/images/drasi_components-55d54cc79879f8190e7db39e55fbdaa4.png"},28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>a});var o=t(96540);const i={},r=o.createContext(i);function s(e){const n=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),o.createElement(r.Provider,{value:n},e.children)}},80204:e=>{e.exports=JSON.parse('{"permalink":"/azure/drasi-bastion-rbac-automation","source":"@site/blog/2025-06-22-drasiazroleassignment/index.mdx","title":"Automate Azure Bastion with Drasi Realtime RBAC Monitoring","description":"Learn to automate Azure Bastion creation and deletion in real-time using Drasi to monitor Azure Role Assignments.","date":"2025-06-21T13:25:24.603Z","tags":[{"inline":true,"label":"Azure","permalink":"/tags/azure"}],"readingTime":45.23,"hasTruncateMarker":true,"authors":[{"name":"Luke Murray","title":"Author","url":"https://luke.geek.nz","imageURL":"https://luke.geek.nz/img/logo.png","key":"Luke","page":null}],"frontMatter":{"title":"Automate Azure Bastion with Drasi Realtime RBAC Monitoring","metaDescription":"Use Drasi to monitor Azure Role Assignments and automate Azure Bastion creation or deletion in real-time.","tags":["Azure"],"categories":["Azure"],"authors":["Luke"],"slug":"azure/drasi-bastion-rbac-automation","keywords":["Azure","Drasi","Azure Bastion","RBAC","Role-Based Access Control","Event-driven architecture","Real-time monitoring","Azure Activity Logs","Event Hub","Azure Functions","PowerShell","AKS","Kubernetes","Event Grid","Automation","Infrastructure as Code","Change Data Processing","Cypher query language","VM Administrator Login","Workload Identity","Managed Identity","Azure Resource Manager","Cloud Native Computing Foundation","CNCF"],"description":"Learn to automate Azure Bastion creation and deletion in real-time using Drasi to monitor Azure Role Assignments.","date":"2025-06-21T13:25:24.603Z"},"unlisted":false,"prevItem":{"title":"Model Context Protocol (MCP) in VS Code with Microsoft Learn","permalink":"/azure/mcp-vscode-microsoft-learn"},"nextItem":{"title":"Validate Azure Zone Redundancy with az zones CLI","permalink":"/azure/zone-redundancy-cli"}}')}}]);