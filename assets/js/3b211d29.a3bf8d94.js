"use strict";(self.webpackChunklukemurraynz=self.webpackChunklukemurraynz||[]).push([[34623],{24564:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>l,frontMatter:()=>s,metadata:()=>a,toc:()=>p});var a=i(26814),n=i(74848),r=i(28453);const s={title:"Container Patching with Azure DevOps, Trivy and Copacetic",metaDescription:"Learn how to automate container patching with Trivy, Copacetic, and Azure DevOps. This guide covers vulnerability scanning, image patching, and pushing to Azure Container Registry.",date:new Date("2024-07-22T09:28:31.063Z"),tags:["Azure"],categories:["Azure"],authors:["Luke"],slug:"azure/automate-container-patching-with-trivy-copacetic-azure-devops",keywords:["azure","trivy","copa","Copacetic","Azure DevOps","ado","containers","containerregistry"],description:"Learn how to automate Docker container patching with Trivy, Copacetic, and Azure DevOps. This guide covers vulnerability scanning, image patching, and pushing to Azure Container Registry."},o=void 0,c={authorsImageUrls:[void 0]},p=[{value:"\ud83d\udccbOverview",id:"overview",level:2},{value:"\ud83d\ude80Azure DevOps deploy",id:"azure-devops-deploy",level:2},{value:"\ud83d\udee0\ufe0fPipeline",id:"\ufe0fpipeline",level:3},{value:"\u2705Deployment results",id:"deployment-results",level:3}];function h(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",mermaid:"mermaid",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.a,{href:"https://project-copacetic.github.io/copacetic/website/",children:"Copacetic"})," (or Copa for short) is a CLI tool written in Go and based on buildkit that can be used to directly patch container images given the vulnerability scanning results from popular tools like ",(0,n.jsx)(t.a,{href:"https://github.com/aquasecurity/trivy",children:"Trivy"}),"."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.a,{href:"https://aquasecurity.github.io/trivy/",children:"Trivy"})," is a security scanner that can scan container images for vulnerabilities. It is a simple and comprehensive scanner that can be used to scan images for vulnerabilities in the OS packages, application dependencies, and language-specific packages, supplemented by vulnerability databases supplemented with Copa, which can be used to patch the vulnerabilities found by Trivy; this tool can be used to quickly patch container images without going upstream for a full rebuild, which may require more time, and the involvement of multiple teams ",(0,n.jsx)(t.em,{children:"(ie Developers, Q&A, Operations, Support)"})," to patch, test and deploy."]}),"\n",(0,n.jsxs)(t.p,{children:["In this article, we will use ",(0,n.jsx)(t.a,{href:"https://azure.microsoft.com/products/devops?WT.mc_id=AZ-MVP-5004796",children:"Azure DevOps"})," to run a pipeline that will use ",(0,n.jsx)(t.a,{href:"https://aquasecurity.github.io/trivy/",children:"Trivy"})," to scan a container image for vulnerabilities, and then use ",(0,n.jsx)(t.a,{href:"https://project-copacetic.github.io/copacetic/website/",children:"Copa"})," to patch the vulnerabilities found by Trivy, and then push the patched image to an ",(0,n.jsx)(t.a,{href:"https://azure.microsoft.com/products/container-registry?WT.mc_id=AZ-MVP-5004796",children:"Azure Container Registry (ACR)"}),"."]}),"\n","\n",(0,n.jsx)(t.h2,{id:"overview",children:"\ud83d\udccbOverview"}),"\n",(0,n.jsxs)(t.admonition,{type:"info",children:[(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.a,{href:"https://github.com/project-copacetic/copacetic",children:"Copa"})," gives the ability to patch containers quickly without going upstream for a complete rebuild. As the window between ",(0,n.jsx)(t.a,{href:"https://www.bleepingcomputer.com/news/security/hackers-scan-for-vulnerabilities-within-15-minutes-of-disclosure/",children:"vulnerability disclosure and active exploitation"})," continues to narrow, there is a growing operational need to patch critical security vulnerabilities in container images so they can be quickly redeployed into production."]}),(0,n.jsx)(t.p,{children:"In addition to filling the operational gap not met by left-shift security practices and tools, the ability of Copa to patch a container without requiring a rebuild of the container image provides other benefits:"}),(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"Container image patching",src:i(95761).A+"",width:"624",height:"230"})}),(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Allows users other than the image publishers also to patch container images, such as DevSecOps engineers."}),"\n",(0,n.jsx)(t.li,{children:"Reduces the storage and transmission costs of redistributing patched images by only creating an additional patch layer instead of rebuilding the entire image, which usually results in different layer hashes that break layer caching."}),"\n",(0,n.jsx)(t.li,{children:"Reduces the turnaround time for patching a container image by not having to wait for base image updates and being a faster operation than a full image rebuild."}),"\n",(0,n.jsx)(t.li,{children:"Reduces the complexity of patching the image from running a rebuild pipeline to running a single tool on the image."}),"\n"]})]}),"\n",(0,n.jsx)(t.admonition,{type:"warning",children:(0,n.jsx)(t.p,{children:"Copa currently only supports OS package vulnerabilities and does not support application dependencies or language-specific packages. When validated and tested with developers, it is recommended to use Copa in conjunction with Trivy to patch OS package vulnerabilities and other tools to patch application dependencies and language-specific packages."})}),"\n",(0,n.jsxs)(t.admonition,{type:"info",children:[(0,n.jsx)(t.p,{children:"The copa tool is an extensible engine that:"}),(0,n.jsx)(t.p,{children:"Parses the needed update packages from the container image\u2019s vulnerability report produced by a scanner like Trivy. New adapters can be written to accommodate more report formats.\nObtains and processes the needed update packages using the appropriate package manager tools such as apt, apk, etc. New adapters can be written to support more package managers.\nApplies the resulting update binaries to the container image using buildkit."}),(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"Copa",src:i(82088).A+"",width:"624",height:"242"})}),(0,n.jsx)(t.p,{children:"This approach is motivated by the core principles of making direct container patching broadly applicable and accessible:"}),(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["Copa supports patching existing container images ",(0,n.jsx)(t.em,{children:"(Devs don't need to build their images using specific tools or modify them in some way to support container patching)"}),"."]}),"\n",(0,n.jsx)(t.li,{children:"Copa supports containers without package managers, including distro less containers"}),"\n",(0,n.jsxs)(t.li,{children:["Copa works with the existing vulnerability scanning and mitigation ecosystems.\n",(0,n.jsx)(t.em,{children:"(Image publishers don't need to create new workflows for container patching since Copa supports patching container images using the security update packages already being published today.)"}),"\n",(0,n.jsx)(t.em,{children:"(Consumers do not need to migrate to a new and potentially more limited support ecosystem for custom distros or change their container vulnerability scanning pipelines to include remediation since Copa can be integrated seamlessly as an extra step to patch containers based on those scanning reports.)"})]}),"\n",(0,n.jsxs)(t.li,{children:["Copa reduces the technical expertise needed and waiting on dependencies needed to patch an image.\n",(0,n.jsx)(t.em,{children:"(For OS package vulnerabilities, no specialized knowledge about a specific image is needed to be patch it as Copa relies on the vulnerability remediation knowledge already embedded in the reports produced by popular container scanning tools today.)"})]}),"\n"]})]}),"\n",(0,n.jsx)(t.h2,{id:"azure-devops-deploy",children:"\ud83d\ude80Azure DevOps deploy"}),"\n",(0,n.jsx)(t.p,{children:"So let's get started by creating a new Azure DevOps pipeline that will use Trivy to scan a container image for vulnerabilities, and then use Copa to patch the vulnerabilities found by Trivy, and then push the patched image to an Azure Container Registry (ACR)."}),"\n",(0,n.jsxs)(t.p,{children:["First we need to create the Service Connection, we can create a ",(0,n.jsx)(t.a,{href:"https://learn.microsoft.com/azure/devops/pipelines/ecosystems/containers/publish-to-acr?WT.mc_id=AZ-MVP-5004796",children:"Docker Registry service connection"}),"."]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"Create Service Connection",src:i(95232).A+"",width:"681",height:"1021"})}),"\n",(0,n.jsx)(t.p,{children:"Then, we can use the pipeline to connect to the Container Registry and patch the Container."}),"\n",(0,n.jsx)(t.mermaid,{value:"graph TD\n  A[Start] --\x3e B{Parameters}\n  B --\x3e C{Variables}\n  C --\x3e D[Stages]\n  D --\x3e E[Stage: Patch]\n  E --\x3e F[Job: Copacetic]\n  F --\x3e G[Step: Setup]\n  G --\x3e H[Step: Scan and Patch Image]\n  H --\x3e I[Step: Upload Results]\n  I --\x3e J[Step: Push Patched Image to ACR]\n  J --\x3e K[End]"}),"\n",(0,n.jsx)(t.p,{children:"Make sure you update the parameters, and Service Principal variable name with the up-to-date versions of Trivy, Copacetic and BuildKit, at the time you run this, and of course the container image you want to patch."}),"\n",(0,n.jsx)(t.h3,{id:"\ufe0fpipeline",children:"\ud83d\udee0\ufe0fPipeline"}),"\n",(0,n.jsxs)(t.p,{children:["You can also find the full pipeline code at the following gist: ",(0,n.jsx)(t.a,{href:"https://gist.github.com/lukemurraynz/ea00bc9c6b6a9468a82f3b679c40a220",children:"lukemurraynz/copacetic.yml"}),"."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-yaml",metastring:"copacetic.yml",children:"# The name of the pipeline, including the date and a revision number\nname: copa_$(Date:yyyyMMdd)_$(Rev:r)\n\n# This pipeline is not triggered automatically by any event\ntrigger: none\n\n# This pipeline is not triggered automatically by any pull request\npr: none\n\n# Parameters for the pipeline\nparameters:\n  # The Docker image to be patched\n  # This parameter specifies the Docker image that will be patched by the pipeline.\n  - name: image\n    displayName: Image To Patch\n    type: string\n    default: \"azcontainerregistry.azurecr.io/api-firewall:0.6.14\"\n\n  # The version of Trivy to be used\n  # Trivy is a Simple and Comprehensive Vulnerability Scanner for Containers and other Artifacts,\n  # suitable for CI. This parameter specifies the version of Trivy to be used in the pipeline.\n  - name: trivyVersion\n    displayName: 'Trivy Version'\n    type: string\n    default: '0.53.0'\n\n  # The version of Copacetic to be used\n  # Copacetic is a tool for checking the health of services. This parameter specifies the version\n  # of Copacetic to be used in the pipeline.\n  - name: copaVersion\n    displayName: 'Copacetic Version'\n    type: string\n    default: '0.7.0'\n\n  # The version of BuildKit to be used\n  # BuildKit is a toolkit for converting source code to build artifacts in an efficient, \n  # expressive and repeatable manner. This parameter specifies the version of BuildKit to be used in the pipeline.\n  - name: buildkitVersion\n    displayName: 'BuildKit Version'\n    type: string\n    default: '0.15.0'\n\n# Variables for the pipeline\nvariables:\n  # The port on which BuildKit will run\n  buildkit.port: \"8888\"\n  # The name of the service connection to be used\n  serviceConnectionName: 'azcontainerregistry'\n  # The system.debug variable is set to true. This enables verbose logging for the entire pipeline.\n  # When this is enabled, Azure Pipelines will output more detailed logs, which can be helpful for debugging.\n  system.debug: false\n\nstages:\n  - stage: patch\n    jobs:\n    - job: Copacetic\n      steps:\n        - bash: |\n            # Exit immediately if a command exits with a non-zero status\n            set -e\n            # Download the Trivy tarball from the specified URL\n            wget \"https://github.com/aquasecurity/trivy/releases/download/v${{ parameters.trivyVersion }}/trivy_${{ parameters.trivyVersion }}_Linux-64bit.tar.gz\"\n            # Extract the Trivy binary to /usr/local/bin\n            sudo tar -C /usr/local/bin -zxvf trivy_${{ parameters.trivyVersion }}_Linux-*.tar.gz trivy\n            # Make the Trivy binary executable\n            sudo chmod +x /usr/local/bin/trivy\n            # Download the Copacetic tarball from the specified URL\n            wget \"https://github.com/project-copacetic/copacetic/releases/download/v${{ parameters.copaVersion }}/copa_${{ parameters.copaVersion }}_linux_amd64.tar.gz\"\n            # Extract the Copacetic binary to /usr/local/bin\n            sudo tar -C /usr/local/bin -zxvf copa_${{ parameters.copaVersion }}_*.tar.gz copa\n            # Make the Copacetic binary executable\n            sudo chmod +x /usr/local/bin/copa\n          displayName: Download and Install Trivy and Copa\n\n        - bash: |\n            # This script is used to run a new Docker container in the background.\n            # 'set -e' is used to exit the script immediately if a command exits with a non-zero status.\n            set -e\n            # The 'docker run' command is used to start a new Docker container.\n            # The '--detach' option is used to run the container in the background and print the new container ID.\n            # The '--rm' option is used to automatically remove the container when it exits.\n            # The '--privileged' option is used to give extended privileges to this container.\n            # The '-p' option is used to publish the container's port to the host.\n            # The '--name' option is used to assign a name to the container.\n            # The '--entrypoint' option is used to overwrite the default ENTRYPOINT of the image.\n            # The '--addr' option is used to specify the listening address of the BuildKit daemon.\n            docker run \\\n              --detach \\\n              --rm \\\n              --privileged \\\n              -p 127.0.0.1:$(buildkit.port):$(buildkit.port)/tcp \\\n              --name buildkitd \\\n              --entrypoint buildkitd \\\n              \"moby/buildkit:v${{ parameters.buildkitVersion }}\" \\\n              --addr tcp://0.0.0.0:$(buildkit.port)\n          displayName: Run Buildkit\n\n        - task: Docker@2\n          displayName: Login to ACR\n          inputs:\n            command: login\n            containerRegistry: $(serviceConnectionName)\n            # This task uses the Docker@2 task to log in to Azure Container Registry (ACR)\n            # The 'command: login' input tells the task to perform a 'docker login' command\n            # The 'containerRegistry: $(serviceConnectionName)' input specifies the service connection to use for logging in\n            # The service connection contains the credentials needed to authenticate with ACR\n\n        - bash: |\n            # Exit immediately if a command exits with a non-zero status\n            set -e\n            # Extract the tag from the image name\n            tag=${IMAGE#*:}\n            # Extract the repository from the image name\n            repo=${IMAGE%:*}\n            # Scan the image with Trivy and store the output as a JSON file named copa-patch.json\n            stdbuf -oL trivy image --vuln-type os --ignore-unfixed $IMAGE | grep Total\n          env:\n            # The image to be patched\n            IMAGE: ${{ parameters.image }}\n          displayName: Scan image for DevOps Output\n\n        - bash: |\n            # Exit immediately if a command exits with a non-zero status\n            set -e\n            # Extract the tag from the image name\n            tag=${IMAGE#*:}\n            # Extract the repository from the image name\n            repo=${IMAGE%:*}\n            # Scan the image with Trivy and store the output as a JSON file named copa-patch.json\n            stdbuf -oL trivy image --vuln-type os --ignore-unfixed -f json $IMAGE | tee copa-patch.json\n            # Use the scan result to patch the image, if needed\n            copa patch \\\n              -i $IMAGE \\\n              -r copa-patch.json \\\n              -t $tag-patched \\\n              -a tcp://0.0.0.0:$(buildkit.port)\n            docker save -o patched-image.tar $repo:$tag-patched\n            # The 'copa patch' command is used to patch the image.\n            # '-i $IMAGE' specifies the image to be patched.\n            # '-r copa-patch.json' specifies the file containing the scan results.\n            # '-t $tag-patched' specifies the tag for the patched image.\n            # '-a tcp://0.0.0.0:$(buildkit.port)' specifies the address of the BuildKit daemon.\n            # The 'docker save' command is used to save the new patched image as a tar file that can be used later.\n          env:\n            # The image to be patched\n            IMAGE: ${{ parameters.image }}\n          displayName: Scan and Patch Image\n\n        - task: PublishPipelineArtifact@1\n          inputs:\n            targetPath: $(System.DefaultWorkingDirectory)/copa-patch.json\n            artifactName: scan_results\n          displayName: Upload Scan Results as a pipeline artifact\n          # This task uses the PublishPipelineArtifact@1 task to upload the scan results as a pipeline artifact\n          # The 'targetPath: $(System.DefaultWorkingDirectory)/copa-patch.json' input specifies the file to upload\n          # The 'artifactName: scan_results' input specifies the name of the artifact in the pipeline\n\n        - task: PublishPipelineArtifact@1\n          inputs:\n            targetPath: $(System.DefaultWorkingDirectory)/patched-image.tar\n            artifactName: patched\n          displayName: Upload patched image as a pipeline artifact\n          # This task uses the PublishPipelineArtifact@1 task to upload the patched image as a pipeline artifact\n          # The 'targetPath: $(System.DefaultWorkingDirectory)/patched-image.tar' input specifies the file to upload\n          # The 'artifactName: patched' input specifies the name of the artifact in the pipeline\n\n        - bash: |\n            # Exit immediately if a command exits with a non-zero status\n            set -e\n            # Print each command that is executed to the terminal\n            set -x\n            # Extract the tag from the image name\n            tag=${IMAGE#*:}\n            # Extract the repository from the image name\n            repo=${IMAGE%:*}\n            # Tag the patched image with the appropriate repository name\n            # The 'docker tag' command creates a new alias for the image\n            # The format is 'docker tag source_image target_image'\n            # In this case, the source and target images are the same, so this command effectively does nothing\n            docker tag $repo:$tag-patched $repo:$tag-patched\n            # Push the patched image back to Azure Container Registry\n            # The 'docker push' command pushes an image or a repository to a registry\n            docker push $repo:$tag-patched\n          env:\n            # The image to be patched\n            IMAGE: ${{ parameters.image }}\n          displayName: Push Patched Image to ACR\n"})}),"\n",(0,n.jsxs)(t.p,{children:["For demo purposes, I am using an older version of the ",(0,n.jsx)(t.a,{href:"https://hub.docker.com/_/api-firewall",children:"api-firewall"})," image, which has known vulnerabilities that must be patched."]}),"\n",(0,n.jsx)(t.h3,{id:"deployment-results",children:"\u2705Deployment results"}),"\n",(0,n.jsx)(t.p,{children:"Let's look at the image in Azure Container Registry before the patch."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"API FW Before Patch",src:i(43288).A+"",width:"1603",height:"574"})}),"\n",(0,n.jsx)(t.p,{children:"Now, let us deploy the pipeline and see the results."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"API FW Before Patch",src:i(3124).A+"",width:"1840",height:"943"})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"Copa ADO pipeline",src:i(93981).A+"",width:"2238",height:"1190"})}),"\n",(0,n.jsx)(t.p,{children:"After the pipeline has run, we can see the patched image in the Azure Container Registry."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"API Firewall",src:i(95919).A+"",width:"1552",height:"552"})}),"\n",(0,n.jsx)(t.p,{children:"If we re-run the pipeline again, this time targetting our new patched image, we can see that there are no patchable vulnerabilities found."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"Copa ADO pipeline",src:i(74220).A+"",width:"2238",height:"1190"})}),"\n",(0,n.jsx)(t.admonition,{type:"warning",children:(0,n.jsx)(t.p,{children:"Remember that Copacetic is a tool that can be used to quickly patch container images without going upstream for a full rebuild - HOWEVER, it does not replace the need to do a full rebuild of the image, as it only patches OS package vulnerabilities, and does not support application dependencies or language-specific packages. It is also recommended not to layer patch on top of patch, as this can lead to a bloated image, and potential conflicts between patches, consider patching the same base image other an an already patched image, if new updates occur."})})]})}function l(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},95919:(e,t,i)=>{i.d(t,{A:()=>a});const a=i.p+"assets/images/api-firewall-acr-aftercopapatch-7ed500a7d4a5bbc90c4794f10f0792de.png"},43288:(e,t,i)=>{i.d(t,{A:()=>a});const a=i.p+"assets/images/api-firewall-acr-beforecopapatch-f7b59d864bc68fe82c35a4dd0962e007.png"},3124:(e,t,i)=>{i.d(t,{A:()=>a});const a=i.p+"assets/images/api-firewall-ado-beforecopapatch-888841a2192db7c95f253180b5f7eeb8.png"},74220:(e,t,i)=>{i.d(t,{A:()=>a});const a=i.p+"assets/images/copa-pipelinererun-7b0415f1a2bdb060abffb91500174d26.gif"},93981:(e,t,i)=>{i.d(t,{A:()=>a});const a=i.p+"assets/images/copa-pipelinerun-f0ba56d6bbe249b36261d27d157b6870.gif"},95761:(e,t,i)=>{i.d(t,{A:()=>a});const a=i.p+"assets/images/direct-image-patching-9660f2e54a813b9973eec665e7bacff9.png"},95232:(e,t,i)=>{i.d(t,{A:()=>a});const a=i.p+"assets/images/docker-registry-acr-serviceconnection-899ff4e48ae4dbd6aed45af177283510.png"},82088:(e,t,i)=>{i.d(t,{A:()=>a});const a=i.p+"assets/images/vulnerability-patch-e57f146e24f2c339b2f80c0bb48b95bf.png"},28453:(e,t,i)=>{i.d(t,{R:()=>s,x:()=>o});var a=i(96540);const n={},r=a.createContext(n);function s(e){const t=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:s(e.components),a.createElement(r.Provider,{value:t},e.children)}},26814:e=>{e.exports=JSON.parse('{"permalink":"/azure/automate-container-patching-with-trivy-copacetic-azure-devops","source":"@site/blog/2024-07-22-trivy-copacetic-ado/index.mdx","title":"Container Patching with Azure DevOps, Trivy and Copacetic","description":"Learn how to automate Docker container patching with Trivy, Copacetic, and Azure DevOps. This guide covers vulnerability scanning, image patching, and pushing to Azure Container Registry.","date":"2024-07-22T09:28:31.063Z","tags":[{"inline":true,"label":"Azure","permalink":"/tags/azure"}],"readingTime":11.14,"hasTruncateMarker":true,"authors":[{"name":"Luke Murray","title":"Author","url":"https://luke.geek.nz","imageURL":"https://luke.geek.nz/img/logo.png","key":"Luke","page":null}],"frontMatter":{"title":"Container Patching with Azure DevOps, Trivy and Copacetic","metaDescription":"Learn how to automate container patching with Trivy, Copacetic, and Azure DevOps. This guide covers vulnerability scanning, image patching, and pushing to Azure Container Registry.","date":"2024-07-22T09:28:31.063Z","tags":["Azure"],"categories":["Azure"],"authors":["Luke"],"slug":"azure/automate-container-patching-with-trivy-copacetic-azure-devops","keywords":["azure","trivy","copa","Copacetic","Azure DevOps","ado","containers","containerregistry"],"description":"Learn how to automate Docker container patching with Trivy, Copacetic, and Azure DevOps. This guide covers vulnerability scanning, image patching, and pushing to Azure Container Registry."},"unlisted":false,"prevItem":{"title":"Azure Hackathon Vending with Terraform","permalink":"/azure/hackathon-vending-project"},"nextItem":{"title":"Push Docker Images to Azure Container Registry with GitHub Codespaces","permalink":"/azure/push-docker-images-to-acr-using-github-codespaces"}}')}}]);